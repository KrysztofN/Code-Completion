{"text": "<fim_prefix>from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events imp<fim_suffix>xt=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n<fim_middle>ort SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(te", "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n", "file_path": "assets\\actions.py", "split_index": 0}
{"text": "<fim_prefix>from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter<fim_suffix>eathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n<fim_middle>_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openw", "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n", "file_path": "assets\\actions.py", "split_index": 1}
{"text": "<fim_prefix>from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity<fim_suffix>e(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n<fim_middle>, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_messag", "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n", "file_path": "assets\\actions.py", "split_index": 2}
{"text": "<fim_prefix>from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction,<fim_suffix>   city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n<fim_middle> Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                 ", "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n", "file_path": "assets\\actions.py", "split_index": 4}
{"text": "<fim_prefix>from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 p<fim_suffix>'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n<fim_middle>rywatno\u015bci przed kontynuacj\u0105.", "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n", "file_path": "assets\\app.py", "split_index": 0}
{"text": "<fim_prefix>from flask import Flask, render_template, jsonify, req<fim_suffix> \"__main__\":\n    app.run(debug=True, port=3000)\n<fim_middle>uest\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ ==", "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n", "file_path": "assets\\app.py", "split_index": 1}
{"text": "<fim_prefix>from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_re<fim_suffix> prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n<fim_middle>sponses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki", "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n", "file_path": "assets\\app.py", "split_index": 2}
{"text": "<fim_prefix>from flask im<fim_suffix> rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n<fim_middle>port Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n   ", "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n", "file_path": "assets\\app.py", "split_index": 3}
{"text": "<fim_prefix>from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    glob<fim_suffix>s)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n<fim_middle>al policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_response", "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n", "file_path": "assets\\app.py", "split_index": 4}
{"text": "<fim_prefix>\n# function to calculate the difference<fim_suffix>from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n<fim_middle> between\n# date ", "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n", "file_path": "assets\\calc_diff.py", "split_index": 0}
{"text": "<fim_prefix>\n# function to calculat<fim_suffix>TAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n<fim_middle>e the difference between\n# date from the user and current date (UNIT TIMES", "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n", "file_path": "assets\\calc_diff.py", "split_index": 2}
{"text": "<fim_prefix>\n# function to calculate the difference between\n# date from the user and current date (U<fim_suffix>ate1)/86400\n    return result\n<fim_middle>NIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - d", "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n", "file_path": "assets\\calc_diff.py", "split_index": 3}
{"text": "<fim_prefix>\n# function<fim_suffix>ate1, date2):\n    result = (date2 - date1)/86400\n    return result\n<fim_middle> to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(d", "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n", "file_path": "assets\\calc_diff.py", "split_index": 4}
{"text": "<fim_prefix>from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"Ap<fim_suffix>s = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n<fim_middle>ril\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_format", "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n", "file_path": "assets\\date_check.py", "split_index": 0}
{"text": "<fim_prefix>from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y<fim_suffix>, \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n<fim_middle>\",\n        \"%B %d %y\"", "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n", "file_path": "assets\\date_check.py", "split_index": 1}
{"text": "<fim_prefix>from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"M<fim_suffix> = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n<fim_middle>ar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data", "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n", "file_path": "assets\\date_check.py", "split_index": 3}
{"text": "<fim_prefix>from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie<fim_suffix> %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n<fim_middle>\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d", "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n", "file_path": "assets\\date_check.py", "split_index": 4}
{"text": "<fim_prefix>import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, boa<fim_suffix>\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False<fim_middle>rd_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0", "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False", "file_path": "assets\\myplayer.py", "split_index": 0}
{"text": "<fim_prefix>import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_ne<fim_suffix> player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False<fim_middle>eded: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self,", "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False", "file_path": "assets\\myplayer.py", "split_index": 1}
{"text": "<fim_prefix>import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for e<fim_suffix> 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False<fim_middle>mpty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player", "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False", "file_path": "assets\\myplayer.py", "split_index": 2}
{"text": "<fim_prefix>import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n<fim_suffix>def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False<fim_middle>      \n    @abstractmethod\n    ", "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False", "file_path": "assets\\myplayer.py", "split_index": 3}
{"text": "<fim_prefix>import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.<fim_suffix>   \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False<fim_middle>\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n     ", "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False", "file_path": "assets\\myplayer.py", "split_index": 4}
{"text": "<fim_prefix>import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        bes<fim_suffix>AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()<fim_middle>t_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = ", "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()", "file_path": "assets\\player.py", "split_index": 1}
{"text": "<fim_prefix>import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta,<fim_suffix>e(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()<fim_middle> True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in rang", "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()", "file_path": "assets\\player.py", "split_index": 2}
{"text": "<fim_prefix>import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window ==<fim_suffix>= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()<fim_middle> opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >", "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()", "file_path": "assets\\player.py", "split_index": 3}
{"text": "<fim_prefix>import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n      <fim_suffix>width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()<fim_middle>  return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_", "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()", "file_path": "assets\\player.py", "split_index": 4}
{"text": "<fim_prefix># from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n# <fim_suffix>B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n<fim_middle>    month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%", "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n", "file_path": "assets\\test.py", "split_index": 0}
{"text": "<fim_prefix># from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwi<fim_suffix>formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n<fim_middle>ec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_", "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n", "file_path": "assets\\test.py", "split_index": 1}
{"text": "<fim_prefix># from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#       <fim_suffix>}: {get_date(test_data)}\")\n<fim_middle>  \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data", "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n", "file_path": "assets\\test.py", "split_index": 3}
{"text": "<fim_prefix># from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#      <fim_suffix> 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n<fim_middle>       if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip", "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n", "file_path": "assets\\test.py", "split_index": 4}
{"text": "<fim_prefix># import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if r<fim_suffix> Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n<fim_middle>esponse.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny.", "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n", "file_path": "assets\\test2.py", "split_index": 1}
{"text": "<fim_prefix># import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description']<fim_suffix>\"\n# check_bot(token)\n<fim_middle>)\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token", "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n", "file_path": "assets\\test2.py", "split_index": 2}
{"text": "<fim_prefix># import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         <fim_suffix># check_bot(token)\n<fim_middle>print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n", "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n", "file_path": "assets\\test2.py", "split_index": 3}
{"text": "<fim_prefix># import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['use<fim_suffix> print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n<fim_middle>rname'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#        ", "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n", "file_path": "assets\\test2.py", "split_index": 4}

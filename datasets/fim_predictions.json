[
  {
    "file_path": "assets\\actions.py",
    "split_index": 0,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events imp",
    "predicted_middle": "ort Restarted, FollowupAction\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.forms import FormAction, FormField, FormText\nfrom rasa_sdk.executor.events import SlotSet, FollowupAction\nfrom rasa_sdk.forms.events import TextInput, TextOutput\nfrom rasa_sdk.forms.utils import get_default_locale\n\nfrom rasa_nlu.constants import DEFAULT_NLU_MODEL_NAME\nfrom rasa_nlu.training_data import TrainingData\n\nclass ActionUtterLoc(Action):",
    "ground_truth_middle": "ort SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(te",
    "suffix": "xt=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.10559447002190532,
    "jaccard_score": 0.028089887640449437,
    "bleu_score": 0.0002501279940300564,
    "rouge1": 0.0893854748603352,
    "rouge2": 0.011235955056179775,
    "rougeL": 0.0670391061452514,
    "confidence": 0.9482866525650024,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\actions.py",
    "split_index": 1,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter",
    "predicted_middle": "znych w {}. \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\n \\",
    "ground_truth_middle": "_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openw",
    "suffix": "eathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.014039933229728569,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.019230769230769232,
    "rouge2": 0.0,
    "rougeL": 0.019230769230769232,
    "confidence": 0.9835585355758667,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\actions.py",
    "split_index": 2,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity",
    "predicted_middle": "year == specific_date.year and date.month == specific_date.month and date.day == specific_date.day:\n                            desc = item['description']\n                            temp = item['temp']\n                            humidity = item['humidity']\n                            wind_speed = item['wind_speed']\n                            clouds = item['clouds']\n\n                    dispatcher.utter_message(text=\"Wybierz danych wskazanego w %s na %s na %s na %s na %s na %s na %s na %s na %s na %s na %s na %s na %s na %s",
    "ground_truth_middle": ", wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_messag",
    "suffix": "e(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.2698004879840403,
    "jaccard_score": 0.0,
    "bleu_score": 0.05688103891971952,
    "rouge1": 0.15053763440860216,
    "rouge2": 0.10989010989010987,
    "rougeL": 0.12903225806451613,
    "confidence": 0.9639387130737305,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\actions.py",
    "split_index": 4,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction,",
    "predicted_middle": "Restarted\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.forms import FormAction\nfrom rasa_sdk.events import SlotSet\nfrom rasa_sdk.forms import FormField\nfrom rasa_sdk.forms import FormFieldWithButtons\nfrom rasa_sdk.forms import FormFieldWithDropdown\nfrom rasa_sdk.forms import FormFieldWithMultiSelect\nfrom rasa_sdk.forms import FormFieldWithTextInput\nfrom rasa_sdk.forms import FormFieldWithTime\nfrom rasa_sdk.forms import FormFieldWithSelect\nfrom",
    "ground_truth_middle": " Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                 ",
    "suffix": "   city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.119622794831906,
    "jaccard_score": 0.02702702702702703,
    "bleu_score": 0.0,
    "rouge1": 0.0653061224489796,
    "rouge2": 0.00823045267489712,
    "rougeL": 0.05714285714285714,
    "confidence": 0.9853171110153198,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\app.py",
    "split_index": 0,
    "prefix": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 p",
    "predicted_middle": "yka.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})",
    "ground_truth_middle": "rywatno\u015bci przed kontynuacj\u0105.",
    "suffix": "'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.03990310895605299,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.9925717115402222,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\app.py",
    "split_index": 1,
    "prefix": "from flask import Flask, render_template, jsonify, req",
    "predicted_middle": "uest\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n@app.route(\"/about\")\ndef about():\n    return render_template(\"about.html\")\n\n@app.route(\"/contact\")\ndef contact():\n    return render_template(\"contact.html\")\n\n@app.route(\"/contact/new\")\ndef contact_new():\n    return render_template(\"contact_new.html\")\n\n@app.route(\"/contact/edit/<int:id>\")\ndef contact_edit(id):",
    "ground_truth_middle": "uest\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ ==",
    "suffix": " \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.18429251793864546,
    "jaccard_score": 0.08641975308641975,
    "bleu_score": 0.11854679199798444,
    "rouge1": 0.2198952879581152,
    "rouge2": 0.11640211640211638,
    "rougeL": 0.2198952879581152,
    "confidence": 0.9817400574684143,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\app.py",
    "split_index": 2,
    "prefix": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_re",
    "predicted_middle": "sponses)\n\n    print(\"Bot Response: \", bot_response)\n\n    if bot_response == 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.':\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    policy_accepted = True\n\n    return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n@app.route('/webhook',",
    "ground_truth_middle": "sponses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki",
    "suffix": " prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.49745820111610356,
    "jaccard_score": 0.17647058823529413,
    "bleu_score": 0.29322393025800614,
    "rouge1": 0.3466666666666666,
    "rouge2": 0.24657534246575347,
    "rougeL": 0.24,
    "confidence": 0.985622763633728,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\app.py",
    "split_index": 3,
    "prefix": "from flask im",
    "predicted_middle": "port Flask, request, jsonify\nfrom rasa_core.agent import Agent\nfrom rasa_core.interpreter import RasaNLUInterpreter\nfrom rasa_core.interpreter import RasaNLUInterpreter\nfrom rasa_core.interpreter import RasaNLUInterpreter\nfrom rasa_core.interpreter import RasaNLUInterpreter\nfrom rasa_core.interpreter import RasaNLUInterpreter\nfrom rasa_core.interpreter import RasaNLUInterpreter\nfrom rasa_core.interpreter import RasaNLUInterpreter\nfrom rasa_core.interpreter import RasaNLUInterpreter",
    "ground_truth_middle": "port Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n   ",
    "suffix": " rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.16345415878471065,
    "jaccard_score": 0.06521739130434782,
    "bleu_score": 0.0,
    "rouge1": 0.09523809523809523,
    "rouge2": 0.016129032258064512,
    "rougeL": 0.07936507936507936,
    "confidence": 0.9849458932876587,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\app.py",
    "split_index": 4,
    "prefix": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    glob",
    "predicted_middle": "g = request.get_json()\n    bot_response = requests.post(RASA_API_URL, json=globge)\n    return jsonify({'response': bot_response})\n\n@app.route('/webhook', methods=['GET'])\ndef webhook_get():\n    global policy_accepted\n    policy_accepted = False\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n@app.route('/webhook', methods=['POST'])\ndef webhook_post():\n    globge = request.get_json()",
    "ground_truth_middle": "al policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_response",
    "suffix": "s)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.4235248116087791,
    "jaccard_score": 0.1,
    "bleu_score": 0.26019178942072946,
    "rouge1": 0.3934426229508196,
    "rouge2": 0.23333333333333334,
    "rougeL": 0.22950819672131145,
    "confidence": 0.9852153062820435,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\calc_diff.py",
    "split_index": 0,
    "prefix": "\n# function to calculate the difference",
    "predicted_middle": "of two dates\ndef calc_dif_unit(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n\n# function to calculate the difference",
    "ground_truth_middle": " between\n# date ",
    "suffix": "from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.1072096132944241,
    "jaccard_score": 0.05,
    "bleu_score": 0.0,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.9777383804321289,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\calc_diff.py",
    "split_index": 2,
    "prefix": "\n# function to calculat",
    "predicted_middle": "e the difference between two dates\n@app.route('/calc_dif', methods=['POST'])\ndef calc_dif():\n    date1 = request.form['date1']\n    date2 = request.form['date2']\n    result = calc_dif(date1, date2)\n    return jsonify(result)\n\n\n@app.route('/calc_dif/<date1>/<date2>', methods=['POST'])\ndef calc_dif_post(date1, date2):\n    result = calc_dif(date1, date2)\n    return jsonify(result)\n\n\n@app.route('/",
    "ground_truth_middle": "e the difference between\n# date from the user and current date (UNIT TIMES",
    "suffix": "TAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.2416618901258549,
    "jaccard_score": 0.125,
    "bleu_score": 0.019585353625856977,
    "rouge1": 0.1176470588235294,
    "rouge2": 0.0909090909090909,
    "rougeL": 0.1176470588235294,
    "confidence": 0.9869358539581299,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\calc_diff.py",
    "split_index": 3,
    "prefix": "\n# function to calculate the difference between\n# date from the user and current date (U",
    "predicted_middle": "ser)\ndef calculate_difference(date1, date2):\n    result = date2 - date1\n    result = result.days\n    result = result.seconds\n    result = result.microseconds\n    result = result.days*86400\n    result = result.seconds*1000\n    result = result.microseconds*1000\n    result = result.days*86400\n    result = result.seconds*1000\n    result = result.microseconds*1000\n    result = result.days*86400\n    result = result.",
    "ground_truth_middle": "NIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - d",
    "suffix": "ate1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.28722835144030934,
    "jaccard_score": 0.23809523809523808,
    "bleu_score": 0.0921890288468912,
    "rouge1": 0.1724137931034483,
    "rouge2": 0.10714285714285714,
    "rougeL": 0.1724137931034483,
    "confidence": 0.9892662763595581,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\calc_diff.py",
    "split_index": 4,
    "prefix": "\n# function",
    "predicted_middle": "s\ndef calculate_date(dat",
    "ground_truth_middle": " to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(d",
    "suffix": "ate1, date2):\n    result = (date2 - date1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.183056260203396,
    "jaccard_score": 0.058823529411764705,
    "bleu_score": 0.0,
    "rouge1": 0.2608695652173913,
    "rouge2": 0.0,
    "rougeL": 0.1739130434782609,
    "confidence": 0.8950293660163879,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\date_check.py",
    "split_index": 0,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"Ap",
    "predicted_middle": "y\",\n        \"jedzec\": \"June\", \"jedzec\": \"July\", \"jedzec\": \"August\", \"jedzec\": \"September\",\n        \"jedzec\": \"October\", \"jedzec\": \"November\", \"jedzec\": \"December\",\n    }\n    return month_pl[date_str]\n\n\ndef convert_date_str(data_str):\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %",
    "ground_truth_middle": "ril\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_format",
    "suffix": "s = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.3104825137195374,
    "jaccard_score": 0.16176470588235295,
    "bleu_score": 0.16651480801798915,
    "rouge1": 0.31666666666666665,
    "rouge2": 0.13559322033898305,
    "rougeL": 0.3,
    "confidence": 0.9620662927627563,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\date_check.py",
    "split_index": 1,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y",
    "predicted_middle": "Y\", \"%B-%Y\", \"%B/%Y\", \"%B.%Y\",\n        \"%B %y\", \"%B-%y\", \"%B/%y\", \"%B.%y\",\n        \"%d %d\", \"%d-%d\", \"%d/%d\", \"%d.%d\", \"%d/%d\",\n        \"%d %b %d\", \"%d-%b %d\", \"%d/%b %d\", \"%d.%b %d\",\n        \"%d %b %Y\", \"%d-%b-%Y\", \"%d/%b-%Y\", \"%d.%b-%Y\",\n        \"%d %b %",
    "ground_truth_middle": "\",\n        \"%B %d %y\"",
    "suffix": ", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.1195939303630694,
    "jaccard_score": 0.038461538461538464,
    "bleu_score": 0.03635735130905531,
    "rouge1": 0.1111111111111111,
    "rouge2": 0.038461538461538464,
    "rougeL": 0.1111111111111111,
    "confidence": 0.9666287899017334,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\date_check.py",
    "split_index": 3,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"M",
    "predicted_middle": "ean\", \"luty\": \"Apr\", \"kwiecie\u0144\": \"May\", \"maj\": \"June\", \"czerwiec\": \"July\",\n        \"lipiec\": \"August\", \"sierpie\u0144\": \"September\", \"wrzesie\u0144\": \"October\", \"pa\u017adziernik\": \"November\",\n        \"listopad\": \"December\", \"grudzie\u0144\": \"January\", \"sty\": \"February\", \"lut\": \"March\", \"mar\": \"April\", \"luty\": \"May\",\n        \"kwiecie\u0144\": \"June",
    "ground_truth_middle": "ar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data",
    "suffix": " = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.15154524807483444,
    "jaccard_score": 0.026785714285714284,
    "bleu_score": 0.007396415313032669,
    "rouge1": 0.03686635944700461,
    "rouge2": 0.0,
    "rougeL": 0.027649769585253458,
    "confidence": 0.9888377785682678,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\date_check.py",
    "split_index": 4,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie",
    "predicted_middle": "\", \"sie\u0144\": \"October\", \"sie\u0144\": \"November\", \"sie\u0144\": \"December\",\n        \"sie\u0144\": \"December\", \"sie\u0144\": \"December\", \"sie\u0144\": \"December\", \"sie\u0144\": \"December\", \"sie\u0144\": \"December\",\n        \"sie\u0144\": \"December\", \"sie\u0144\": \"December\", \"sie\u0144\": \"December\", \"sie\u0144\": \"December\", \"sie\u0144\": \"December\",\n        \"sie\u0144\": \"December",
    "ground_truth_middle": "\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d",
    "suffix": " %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.07330287429787692,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.990864634513855,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\myplayer.py",
    "split_index": 0,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, boa",
    "predicted_middle": "n, board_size, lenght):\n        \"\"\"\n        Initialize the player.\n        \"\"\"\n        self.board_size = board_size\n        self.lenght = lenght\n        self.board = np.zeros((self.board_size, self.board_size))\n        self.score = 0\n        self.winner = None\n        self.is_flexible = False\n\n    def get_board(self):\n        \"\"\"\n        Return the current board.\n        \"\"\"\n        return self.board\n\n    def get_score(self):\n        \"\"\"\n        Return the current score.\n        \"\"\"\n        return self.score\n\n    def get",
    "ground_truth_middle": "rd_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0",
    "suffix": "\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.17932166811854583,
    "jaccard_score": 0.07913669064748201,
    "bleu_score": 0.04554283421632197,
    "rouge1": 0.2578397212543554,
    "rouge2": 0.07719298245614035,
    "rougeL": 0.1672473867595819,
    "confidence": 0.9650779962539673,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\myplayer.py",
    "split_index": 1,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_ne",
    "predicted_middle": "w: int,",
    "ground_truth_middle": "eded: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self,",
    "suffix": " player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.00821377435833621,
    "jaccard_score": 0.017241379310344827,
    "bleu_score": 0.0,
    "rouge1": 0.025,
    "rouge2": 0.0,
    "rougeL": 0.025,
    "confidence": 0.9103198051452637,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\myplayer.py",
    "split_index": 2,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for e",
    "predicted_middle": "xamples.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_score(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the score of the player.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_score_for_move(self, board: np.ndarray, move: int) -> int:\n        \"\"\"\n        Returns the score of the player for a given move.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_score_for_player(self, board: np.ndarray, player_id: int) -> int:\n        \"\"\"\n        Returns the score of the player for",
    "ground_truth_middle": "mpty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player",
    "suffix": " 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.3678259502773918,
    "jaccard_score": 0.20754716981132076,
    "bleu_score": 0.23625104051546955,
    "rouge1": 0.4166666666666667,
    "rouge2": 0.13559322033898305,
    "rougeL": 0.3,
    "confidence": 0.9726722240447998,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\myplayer.py",
    "split_index": 3,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n",
    "predicted_middle": "def get_player_id(self) -> int:\n        \"\"\"\n        Returns the player's id.\n        \"\"\"\n        return self.player_id\n\n    def set_player_id(self, player_id: int) -> None:\n        \"\"\"\n        Set the player's id.\n        \"\"\"\n        self.player_id = player_id\n\n    def get_board_width(self) -> int:\n        \"\"\"\n        Returns the board width.\n        \"\"\"\n        return self.board_width\n\n    def get_board_height(self) -> int:\n        \"\"\"\n        Returns the board height.\n        \"\"\"\n        return self.",
    "ground_truth_middle": "      \n    @abstractmethod\n    ",
    "suffix": "def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.033516160078866944,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.9834256172180176,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\myplayer.py",
    "split_index": 4,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.",
    "predicted_middle": "\"\"\"\n        self.board = np.zeros((self.board_width, self.board_height), dtype=np.int8)\n        self.player_id = 0\n        self.winning_position = -1\n        self.winning_score = -1\n        self.score = 0\n        self.score_history = []\n        self.score_history_index = 0\n        self.score_history_index_history = []\n        self.score_history_index_history_index = 0\n        self.score_history_index_history_index_history = []",
    "ground_truth_middle": "\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n     ",
    "suffix": "   \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.15849618509761856,
    "jaccard_score": 0.021739130434782608,
    "bleu_score": 0.0,
    "rouge1": 0.16129032258064516,
    "rouge2": 0.06521739130434782,
    "rougeL": 0.10752688172043011,
    "confidence": 0.9547037482261658,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\player.py",
    "split_index": 1,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        bes",
    "predicted_middle": "board = np.copy(board_copy)\n                    new_board[col, :] = 0\n                    new_board[0, col] = 0\n                    new_board[self.board_width-1, col] = 0\n                    new_board[0, 0] = 0\n                    new_board[0, self.board_width-1] = 0\n                    new_board[self.board_width-1, 0] = 0\n                    new_board[0, self.board_width-1] = 0\n                    new_board[0, 0",
    "ground_truth_middle": "t_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = ",
    "suffix": "AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.03848645742789554,
    "jaccard_score": 0.017467248908296942,
    "bleu_score": 3.068089259864191e-08,
    "rouge1": 0.09433962264150944,
    "rouge2": 0.03991596638655462,
    "rougeL": 0.0880503144654088,
    "confidence": 0.9807966351509094,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\player.py",
    "split_index": 2,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta,",
    "predicted_middle": "board = np.copy(board_copy)\n                    new_board[col] = 0\n                    new_board[col] = 1\n                    new_board[col] = 2\n                    new_board[col] = 3\n                    new_board[col] = 4\n                    new_board[col] = 5\n                    new_board[col] = 6\n                    new_board[col] = 7\n                    new_board[col] = 8\n                    new_board[col] = 9\n                    new_board[col] = 10\n                    new_board[col]",
    "ground_truth_middle": " True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in rang",
    "suffix": "e(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.09786878164859117,
    "jaccard_score": 0.02531645569620253,
    "bleu_score": 0.0,
    "rouge1": 0.25000000000000006,
    "rouge2": 0.018018018018018018,
    "rougeL": 0.21428571428571427,
    "confidence": 0.9941115379333496,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\player.py",
    "split_index": 3,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window ==",
    "predicted_middle": "board = np.copy(board_copy)\n                    new_board[col, :] = 0\n                    new_board[0, col] = 0\n                    new_board[self.board_width-1, col] = 0\n                    new_board[0, 0] = 0\n                    new_board[0, self.board_width-1] = 0\n                    new_board[self.board_width-1, 0] = 0\n                    new_board[0, self.board_width-1] = 0\n                    new_board[0, 0",
    "ground_truth_middle": " opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >",
    "suffix": "= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.05786094648893985,
    "jaccard_score": 0.025157232704402517,
    "bleu_score": 1.6000710428077304e-05,
    "rouge1": 0.14173228346456695,
    "rouge2": 0.06003159557661927,
    "rougeL": 0.12598425196850394,
    "confidence": 0.9807966351509094,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\player.py",
    "split_index": 4,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n      ",
    "predicted_middle": "== board[row + 3, col + 3]\n                    and board[row, col]!= 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board",
    "ground_truth_middle": "  return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_",
    "suffix": "width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.075795446976944,
    "jaccard_score": 0.10982658959537572,
    "bleu_score": 5.928918858786909e-05,
    "rouge1": 0.16,
    "rouge2": 0.09698996655518395,
    "rougeL": 0.13,
    "confidence": 0.9993942975997925,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\test.py",
    "split_index": 0,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n# ",
    "predicted_middle": "2024\"))\n# # print(get_date(\"10 05 24 12\"))\n# # print(get_date(\"4 wrzesie\u0144 2024\"))\n# # print(get_date(\"10 05 24 12 12\"))\n# # print(get_date(\"4 wrzesie\u0144 2024\"))\n# # print(get_date(\"10 05 24 12 12 12\"))\n# # print(get_date(\"4",
    "ground_truth_middle": "    month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%",
    "suffix": "B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.056853515844984145,
    "jaccard_score": 0.009523809523809525,
    "bleu_score": 0.00043792146708943795,
    "rouge1": 0.0761904761904762,
    "rouge2": 0.009615384615384616,
    "rougeL": 0.06666666666666667,
    "confidence": 0.9823911190032959,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\test.py",
    "split_index": 1,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwi",
    "predicted_middle": "convert_date(\"2018-01-01\"))\n# # print(convert_date(\"2018-01-02\"))\n# # print(convert_date(\"2018-01-03\"))\n# # print(convert_date(\"2018-01-04\"))\n# # print(convert_date(\"2018-01-05\"))\n# # print(convert_date(\"2018-01-06\"))\n# # print(convert_date(\"2018",
    "ground_truth_middle": "ec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_",
    "suffix": "formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.1042116336258636,
    "jaccard_score": 0.015873015873015872,
    "bleu_score": 0.01679010684379598,
    "rouge1": 0.12068965517241378,
    "rouge2": 0.017543859649122806,
    "rougeL": 0.12068965517241378,
    "confidence": 0.9926114082336426,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\test.py",
    "split_index": 3,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#       ",
    "predicted_middle": "\",\n#         \"%d-%m\", \"%d/%m\", \"%d/%m\",\n#         \"%d-%m-%Y\", \"%d/%m-%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d/%m-%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d/%m-%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d/%m-%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d/%",
    "ground_truth_middle": "  \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data",
    "suffix": "}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.06932778395563138,
    "jaccard_score": 0.02727272727272727,
    "bleu_score": 0.018163769257316418,
    "rouge1": 0.18354430379746833,
    "rouge2": 0.05095541401273885,
    "rougeL": 0.18354430379746833,
    "confidence": 0.9929959774017334,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\test.py",
    "split_index": 4,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#      ",
    "predicted_middle": "\",\n#         \"%d-%m\", \"%d.%m\", \"%d/%m\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m\", \"%d.%m\", \"%d/%m\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m\", \"%d.%m\", \"%d/%m\",",
    "ground_truth_middle": "       if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip",
    "suffix": " 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.029957017634778274,
    "jaccard_score": 0.03333333333333333,
    "bleu_score": 0.0,
    "rouge1": 0.01886792452830189,
    "rouge2": 0.0,
    "rougeL": 0.01886792452830189,
    "confidence": 0.9933476448059082,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\test2.py",
    "split_index": 1,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if r",
    "predicted_middle": "esponse.status_code == 200:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token i upewnij\n# token = \"your-token\"\n# check_",
    "ground_truth_middle": "esponse.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny.",
    "suffix": " Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.31594668508475937,
    "jaccard_score": 0.15151515151515152,
    "bleu_score": 0.1643128226664618,
    "rouge1": 0.13513513513513511,
    "rouge2": 0.08333333333333331,
    "rougeL": 0.13513513513513511,
    "confidence": 0.9881295561790466,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  },
  {
    "file_path": "assets\\test2.py",
    "split_index": 2,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description']",
    "predicted_middle": ")\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['error'])\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['traceback'])\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['data'])\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['chat']['id'])\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas spr",
    "ground_truth_middle": ")\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token",
    "suffix": "\"\n# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.1527189601713824,
    "jaccard_score": 0.058823529411764705,
    "bleu_score": 0.044585866696163635,
    "rouge1": 0.05063291139240506,
    "rouge2": 0.0,
    "rougeL": 0.05063291139240506,
    "confidence": 0.9880865812301636,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  },
  {
    "file_path": "assets\\test2.py",
    "split_index": 3,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         ",
    "predicted_middle": "print(\"Nie mo\u017cna wykresowa\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107",
    "ground_truth_middle": "print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n",
    "suffix": "# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.10568441342748032,
    "jaccard_score": 0.08695652173913043,
    "bleu_score": 0.003668448693854512,
    "rouge1": 0.2285714285714286,
    "rouge2": 0.18181818181818182,
    "rougeL": 0.2285714285714286,
    "confidence": 0.9751940965652466,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  },
  {
    "file_path": "assets\\test2.py",
    "split_index": 4,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['use",
    "predicted_middle": "r'])\n#             print(\"U\u017cytkownik:\", data['result']['user'])\n#             print(\"U\u017cytkownik:\", data['result']['username'])\n#             print(\"U\u017cytkownik:\", data['result']['first_name'])\n#             print(\"U\u017cytkownik:\", data['result']['last_name'])\n#             print(\"U\u017cytkownik:\", data['result']['email'])\n#             print(\"U\u017cytkownik:\", data['result']['profile_image_url'])\n#             print(\"U\u017cytkownik:\", data['result']['location'])\n#             print(\"U",
    "ground_truth_middle": "rname'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#        ",
    "suffix": " print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.40707002000592374,
    "jaccard_score": 0.1,
    "bleu_score": 0.19275350790994297,
    "rouge1": 0.20588235294117646,
    "rouge2": 0.09090909090909091,
    "rougeL": 0.20588235294117646,
    "confidence": 0.9846821427345276,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  }
]
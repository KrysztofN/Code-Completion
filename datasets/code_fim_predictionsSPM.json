[
  {
    "file_path": "assets\\code_based\\actions.py",
    "split_index": 0,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events imp",
    "predicted_middle": "ort Restarted\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.events import SlotSet\nfrom rasa_sdk.executor import CollectingSession\nfrom rasa_sdk.events import SlotSetEvent\nfrom rasa_sdk.events import SlotSetEventBuilder\nfrom rasa_sdk.events import SlotSetEventBuilderEvent\nfrom rasa_sdk.events import SlotSetEventBuilderEventBuilder\nfrom rasa_sdk.events import SlotSetEventBuilderEventBuilderEventBuilder\nfrom rasa_sdk.events import SlotSetEventBuilderEventBuilderEventBuilderEventBuilder",
    "ground_truth_middle": "ort SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(te",
    "suffix": "xt=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.0864874582870052,
    "jaccard_score": 0.023529411764705882,
    "bleu_score": 0.0,
    "rouge1": 0.0509915014164306,
    "rouge2": 0.005698005698005698,
    "rougeL": 0.0453257790368272,
    "confidence": 0.9809883832931519,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\code_based\\actions.py",
    "split_index": 1,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter",
    "predicted_middle": "None), SlotSet(\"Date\", None)]\n\n    def handle_utter_date(self, dispatcher, userdata, response):\n        \"\"\"\n        Handle the date input.\n        \"\"\"\n        dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n        return [SlotSet(\"Date\", None)]\n\n    def handle_utter_date_2(self, dispatcher, userdata, response):\n        \"\"\"\n        Handle",
    "ground_truth_middle": "_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openw",
    "suffix": "eathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.319909994834894,
    "jaccard_score": 0.05263157894736842,
    "bleu_score": 0.20221045547167313,
    "rouge1": 0.23655913978494625,
    "rouge2": 0.13186813186813187,
    "rougeL": 0.23655913978494625,
    "confidence": 0.9737253189086914,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\code_based\\actions.py",
    "split_index": 2,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity",
    "predicted_middle": "5 minut\u00f3w.\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n                if num == 0:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie 5 minut\u00f3w.\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n                if num == 1:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie 5 minut\u00f3w.\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n                if num == 2:\n                    dispatcher.",
    "ground_truth_middle": ", wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_messag",
    "suffix": "e(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.4830770492802226,
    "jaccard_score": 0.06666666666666667,
    "bleu_score": 0.19900808406441206,
    "rouge1": 0.2716049382716049,
    "rouge2": 0.1518987341772152,
    "rougeL": 0.2469135802469136,
    "confidence": 0.9896107912063599,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\code_based\\actions.py",
    "split_index": 4,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction,",
    "predicted_middle": "_date.setter\ndef set_date(date: str):\n    date = date.replace(\" \", \"-\").replace(\":\", \"-\").replace(\" \", \"-\").replace(\":\", \"-\")\n    date = date.replace(\" \", \"-\").replace(\":\", \"-\").replace(\":\", \"-\")\n    date = date.replace(\" \", \"-\").replace(\":\", \"-\").replace(\":\", \"-\")\n    date = date.replace(\" \", \"-\").replace(\":\", \"-\").replace(\":\", \"-\")\n    date = date.replace(\" \", \"-\").replace(\":\", \"-\").replace(\":\", \"-\")\n    date = date.replace(\" \", \"-",
    "ground_truth_middle": " Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                 ",
    "suffix": "   city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.0981447749971711,
    "jaccard_score": 0.028037383177570093,
    "bleu_score": 0.028276000105684578,
    "rouge1": 0.1461187214611872,
    "rouge2": 0.018433179723502308,
    "rougeL": 0.1461187214611872,
    "confidence": 0.9665852785110474,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 0,
    "prefix": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 p",
    "predicted_middle": "_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n@app.route('/webhook",
    "ground_truth_middle": "rywatno\u015bci przed kontynuacj\u0105.",
    "suffix": "'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.03916919085196172,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.9898088574409485,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 1,
    "prefix": "from flask import Flask, render_template, jsonify, req",
    "predicted_middle": "from flask_cors import CORS\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\nfrom flask_login import LoginManager\nfrom flask_mail import Mail\nfrom flask_mail import Message\nfrom flask_mail import Message\nfrom flask_mail import Mail\nfrom flask_mail import Message\nfrom flask_mail import Mail\nfrom flask_mail import Mail\nfrom flask_mail import Mail\nfrom flask_mail import Mail\nfrom flask_mail import Mail\nfrom flask_mail import Mail\nfrom flask_mail import Mail\nfrom flask_mail import Mail\nfrom flask_mail import Mail",
    "ground_truth_middle": "uest\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ ==",
    "suffix": " \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.09257963654989884,
    "jaccard_score": 0.0125,
    "bleu_score": 0.0,
    "rouge1": 0.04444444444444444,
    "rouge2": 0.0,
    "rougeL": 0.04444444444444444,
    "confidence": 0.9842430353164673,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 2,
    "prefix": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_re",
    "predicted_middle": "sponse_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_reponse_json)",
    "ground_truth_middle": "sponses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki",
    "suffix": " prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.18960644149478742,
    "jaccard_score": 0.02857142857142857,
    "bleu_score": 0.0,
    "rouge1": 0.07142857142857142,
    "rouge2": 0.024390243902439025,
    "rougeL": 0.07142857142857142,
    "confidence": 0.9906182289123535,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 3,
    "prefix": "from flask im",
    "predicted_middle": "port Flask\nfrom flask_restful import Api\nfrom flask_cors import CORS\nfrom flask_jwt_extended import JWTManager\nfrom flask_jwt_extended import jwt_required, get_jwt_identity\nfrom flask_jwt_extended import get_raw_jwt\nfrom flask_jwt_extended import create_access_token\nfrom flask_jwt_extended import get_jwt_claims\nfrom flask_jwt_extended import get_raw_jwt\nfrom flask_jwt_extended import get_raw_jwt_identity\nfrom flask_jwt_extended import get_raw_jwt_claims\nfrom",
    "ground_truth_middle": "port Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n   ",
    "suffix": " rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.15922517583262255,
    "jaccard_score": 0.037037037037037035,
    "bleu_score": 0.0,
    "rouge1": 0.06802721088435373,
    "rouge2": 0.013793103448275862,
    "rougeL": 0.06802721088435373,
    "confidence": 0.9819453954696655,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 4,
    "prefix": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    glob",
    "predicted_middle": "_url = RASA_API_URL + '/v1/weather'\n    r = requests.get(glob_url)\n    if r.status_code == 200:\n        return r.json()\n    else:\n        return \"Error: \" + r.text\n\n@app.route('/webhook/v1/weather', methods=['POST'])\ndef weather():\n    global policy_accepted\n    global policy_name\n    global policy_description\n    global policy_icon\n    global policy_icon_url\n    global policy_icon_url_https\n    global policy_icon_url_http\n    global",
    "ground_truth_middle": "al policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_response",
    "suffix": "s)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.20835000986807953,
    "jaccard_score": 0.06153846153846154,
    "bleu_score": 0.09211082375463954,
    "rouge1": 0.2047244094488189,
    "rouge2": 0.048,
    "rougeL": 0.07874015748031496,
    "confidence": 0.9561454057693481,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\calc_diff.py",
    "split_index": 0,
    "prefix": "\n# function to calculate the difference",
    "predicted_middle": "_date_time_format()\n# function to calculate the difference between the current date and the next date\ndef calc_dif_date_time(date1, date2):\n    result = date2 - date1\n    return result\n\n# function to calculate the difference between the current date and the next date\ndef calc_dif_date_time_date(date1, date2):\n    result = date2 - date1\n    return result\n\n# function to calculate the difference between the current date and the next date\ndef calc_dif_date_time_date_time(date1, date",
    "ground_truth_middle": " between\n# date ",
    "suffix": "from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.07211433545935807,
    "jaccard_score": 0.13043478260869565,
    "bleu_score": 0.0,
    "rouge1": 0.05128205128205127,
    "rouge2": 0.0,
    "rougeL": 0.05128205128205127,
    "confidence": 0.967314600944519,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\code_based\\calc_diff.py",
    "split_index": 2,
    "prefix": "\n# function to calculat",
    "predicted_middle": "# import modules\nimport os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\nfrom scipy.stats import ttest_ind\nfrom scipy.stats import chi2\nfrom scipy.stats import norm\nfrom scipy.stats import chi2_contingency\nfrom scipy.stats import chi2_contingency_pvalue\nfrom scipy.stats import ttest_ind_pvalue\nfrom scipy.stats import chi2_contingency_spearman\nfrom scipy.stats import ttest_ind_spearman\nfrom",
    "ground_truth_middle": "e the difference between\n# date from the user and current date (UNIT TIMES",
    "suffix": "TAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.0958888253541062,
    "jaccard_score": 0.06451612903225806,
    "bleu_score": 0.0,
    "rouge1": 0.02325581395348837,
    "rouge2": 0.0,
    "rougeL": 0.02325581395348837,
    "confidence": 0.9480609893798828,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\code_based\\calc_diff.py",
    "split_index": 3,
    "prefix": "\n# function to calculate the difference between\n# date from the user and current date (U",
    "predicted_middle": "_date_time_difference(self, date1, date2):\n    \"\"\"\n    Calculates the difference between two dates.\n    :param date1: the first date\n    :param date2: the second date\n    :return: the difference between the two dates\n    \"\"\"\n    # convert the date to a datetime object\n    date1 = datetime.datetime.strptime(date1, \"%Y-%m-%d\")\n    date2 = datetime.datetime.strptime(date2, \"%Y-%m-%d\")\n\n    # calculate the difference\n    diff = date1 - date2\n    return diff\n\n\n# function to calculate the difference",
    "ground_truth_middle": "NIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - d",
    "suffix": "ate1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.18489319892427628,
    "jaccard_score": 0.07142857142857142,
    "bleu_score": 0.04482735504657124,
    "rouge1": 0.10666666666666667,
    "rouge2": 0.0273972602739726,
    "rougeL": 0.10666666666666667,
    "confidence": 0.9424536824226379,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\code_based\\calc_diff.py",
    "split_index": 4,
    "prefix": "\n# function",
    "predicted_middle": "def get_date_from_date(date",
    "ground_truth_middle": " to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(d",
    "suffix": "ate1, date2):\n    result = (date2 - date1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.11930464328318054,
    "jaccard_score": 0.0625,
    "bleu_score": 0.0,
    "rouge1": 0.3333333333333333,
    "rouge2": 0.0909090909090909,
    "rougeL": 0.25,
    "confidence": 0.8904387950897217,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\code_based\\date_check.py",
    "split_index": 0,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"Ap",
    "predicted_middle": "\": \"April\", \"luty\": \"May\", \"marzec\": \"April\", \"kwiecie\u0144\": \"April\",\n        \"klaszec\": \"April\", \"luty\": \"May\", \"marzec\": \"April\", \"kwiecie\u0144\": \"April\",\n        \"klaszec\": \"April\", \"luty\": \"May\", \"marzec\": \"April\", \"kwiecie\u0144\": \"April\",\n        \"klaszec\": \"April\", \"luty\": \"May\", \"marzec\": \"April\", \"kwiecie\u0144\": \"",
    "ground_truth_middle": "ril\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_format",
    "suffix": "s = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.20695273913031742,
    "jaccard_score": 0.015873015873015872,
    "bleu_score": 0.11927082877011876,
    "rouge1": 0.036036036036036036,
    "rouge2": 0.0,
    "rougeL": 0.036036036036036036,
    "confidence": 0.9856101870536804,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\code_based\\date_check.py",
    "split_index": 1,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y",
    "predicted_middle": "d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\",\n        \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\",\n        \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\",\n        \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\", \"%d/%b\",\n        \"%d/%b\",",
    "ground_truth_middle": "\",\n        \"%B %d %y\"",
    "suffix": ", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.053439828647991384,
    "jaccard_score": 0.0,
    "bleu_score": 0.0143942641672978,
    "rouge1": 0.07547169811320754,
    "rouge2": 0.039215686274509796,
    "rougeL": 0.07547169811320754,
    "confidence": 0.9895898699760437,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\code_based\\date_check.py",
    "split_index": 3,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"M",
    "predicted_middle": "\"1970\": \"1970\", \"1980\": \"1980\", \"1990\": \"1990\", \"2000\": \"2000\", \"2010\": \"2010\", \"2020\": \"2020\",\n        \"2030\": \"2030\", \"2040\": \"2040\", \"2050\": \"2050\", \"2060\": \"2060\", \"2070\": \"",
    "ground_truth_middle": "ar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data",
    "suffix": " = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.03142348251689376,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.9851004481315613,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\code_based\\date_check.py",
    "split_index": 4,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie",
    "predicted_middle": "\"sierpie\u0144\": \"October\", \"wrzesie\u0144\": \"November\", \"pa\u017adziernik\": \"December\", \"listopad\": \"December\",\n        \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"August\", \"sie\": \"September\", \"sie\": \"October\",\n        \"sie\": \"November\", \"",
    "ground_truth_middle": "\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d",
    "suffix": " %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.11588271215021057,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.010152284263959392,
    "rouge2": 0.0,
    "rougeL": 0.010152284263959392,
    "confidence": 0.9834089875221252,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 0,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, boa",
    "predicted_middle": "def __init__(self, boa     self.board = board\n        self.board_size = board_size\n        self.lenght = lenght\n        self.board_size = board_size\n        self.lenght = lenght\n        self.board_size = board_size\n        self.lenght = lenght\n        self.board_size = board_size\n        self.lenght = lenght\n        self.board_size = board_size\n        self.lenght = lenght\n        self.board_size = board_size\n        self.lenght = lenght\n        self.board",
    "ground_truth_middle": "rd_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0",
    "suffix": "\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.13432033078990102,
    "jaccard_score": 0.023622047244094488,
    "bleu_score": 0.01067277120955923,
    "rouge1": 0.1894736842105263,
    "rouge2": 0.04240282685512367,
    "rougeL": 0.1614035087719298,
    "confidence": 0.9743801355361938,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 1,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_ne",
    "predicted_middle": "_width, board_height) -> None:\n        \"\"\"\n        Initializes the player with the given parameters.\n        \"\"\"\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_neighbours = lenght_neighbours\n        self.board = np.zeros((self.board_width, self.board_height))\n        self.player_id = 1\n        self.board_position = 0\n        self.player_moving_id = 0\n        self.player_move_id = 0\n        self.player_move_value =",
    "ground_truth_middle": "eded: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self,",
    "suffix": " player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.43174292319012175,
    "jaccard_score": 0.14864864864864866,
    "bleu_score": 0.3223877042452184,
    "rouge1": 0.39705882352941174,
    "rouge2": 0.22388059701492538,
    "rougeL": 0.3088235294117647,
    "confidence": 0.9460782408714294,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 2,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for e",
    "predicted_middle": "_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move_history(self, board: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Returns the history of the player's move. The history is represented as a numpy array of size (board_height, board_width) with 0 for e  \"\"\"\n        Returns",
    "ground_truth_middle": "mpty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player",
    "suffix": " 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.32940630469522053,
    "jaccard_score": 0.16091954022988506,
    "bleu_score": 0.14384057800578992,
    "rouge1": 0.32167832167832167,
    "rouge2": 0.0851063829787234,
    "rougeL": 0.19580419580419578,
    "confidence": 0.9772816896438599,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 3,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n",
    "predicted_middle": "_player_id is None:\n        self.player_id = 1\n        \"\"\"\n        Initialize the player. The player id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n    \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with",
    "ground_truth_middle": "      \n    @abstractmethod\n    ",
    "suffix": "def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.1544257463162999,
    "jaccard_score": 0.018518518518518517,
    "bleu_score": 0.0,
    "rouge1": 0.02469135802469136,
    "rouge2": 0.0,
    "rougeL": 0.02469135802469136,
    "confidence": 0.973231315612793,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 4,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.",
    "predicted_middle": "The player id is given as an integer.\n        \"\"\"\n        self.player_id = None\n        \"\"\"\n        The player id is given as an integer.\n        \"\"\"\n        self.board = None\n        \"\"\"\n        The board is given as a numpy array.\n        \"\"\"\n        self.board_width = None\n        \"\"\"\n        The board width is given as an integer.\n        \"\"\"\n        self.board_height = None\n        \"\"\"\n        The board height is given as an integer.\n        \"\"\"\n        self.lenght_needed = None\n        \"\"\"\n        The lenght needed is given as an integer.\n        \"\"\"\n        self.train = None",
    "ground_truth_middle": "\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n     ",
    "suffix": "   \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.2285064723412874,
    "jaccard_score": 0.08602150537634409,
    "bleu_score": 0.07947713339758473,
    "rouge1": 0.3383084577114427,
    "rouge2": 0.15075376884422112,
    "rougeL": 0.24875621890547264,
    "confidence": 0.9716278314590454,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\player.py",
    "split_index": 1,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        bes",
    "predicted_middle": "for i in range(depth):\n            if self.is_terminal(board):\n                return None, self.evaluate_position(board, self.player_id)\n            if board[0, i] == 0:\n                best_move = i\n                break\n\n        if best_move is None:\n            return None, self.evaluate_position(board, self.player_id)\n\n        if maximizing_player:\n            return self.minimax(board, depth-1, alpha, beta, True)\n        else:\n            return self.minimax(board, depth-1, alpha, beta,",
    "ground_truth_middle": "t_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = ",
    "suffix": "AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.056983448295443724,
    "jaccard_score": 0.046413502109704644,
    "bleu_score": 1.277585779307099e-07,
    "rouge1": 0.10602910602910601,
    "rouge2": 0.041666666666666664,
    "rougeL": 0.079002079002079,
    "confidence": 0.9709895253181458,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\code_based\\player.py",
    "split_index": 2,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta,",
    "predicted_middle": "# sprawdzanie pionowo\n        for row in range(self.board_height - 2):\n            for col in range(self.board_width - 1):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 1):\n            for col",
    "ground_truth_middle": " True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in rang",
    "suffix": "e(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.23392783200266154,
    "jaccard_score": 0.16455696202531644,
    "bleu_score": 0.07105340663703662,
    "rouge1": 0.4052863436123348,
    "rouge2": 0.22222222222222224,
    "rougeL": 0.29955947136563876,
    "confidence": 0.9951823353767395,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\code_based\\player.py",
    "split_index": 3,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window ==",
    "predicted_middle": "Nieprawid\u0142e\u015b, wybierz kolumn\u0119 (1-{self.board_width}): \")\n\n    def get_move_value(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub",
    "ground_truth_middle": " opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >",
    "suffix": "= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.06892661145201034,
    "jaccard_score": 0.10588235294117647,
    "bleu_score": 3.0043137116608002e-05,
    "rouge1": 0.11635220125786165,
    "rouge2": 0.05993690851735016,
    "rougeL": 0.09119496855345913,
    "confidence": 0.9804236888885498,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\code_based\\player.py",
    "split_index": 4,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n      ",
    "predicted_middle": "for player in self.players:\n            player.play()\n\n    def get_winner(self):\n        return self.players[0].get_winner()\n\n    def get_score(self):\n        return self.players[0].get_score()\n\n    def get_score_by_player(self, player):\n        return self.players[0].get_score_by_player(player)\n\n    def get_score_by_player_by_score(self, player, score):\n        return self.players[0].get_score_by_player_by_score(player, score",
    "ground_truth_middle": "  return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_",
    "suffix": "width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.08512823909745477,
    "jaccard_score": 0.028901734104046242,
    "bleu_score": 0.00014824876276872697,
    "rouge1": 0.15057283142389527,
    "rouge2": 0.03284072249589491,
    "rougeL": 0.10801963993453355,
    "confidence": 0.9800891876220703,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\code_based\\test.py",
    "split_index": 0,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n# ",
    "predicted_middle": "20 24\",\n#     \"4 10 20 24\",\n#     \"4 10 20 24\",\n#     \"4 10 20 24\",\n#     \"4 10 20 24\",\n#     \"4 10 20 24\",\n#     \"4 10 20 24\",\n#     \"4 10 20 24\",\n#     \"4 10 20 24\",",
    "ground_truth_middle": "    month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%",
    "suffix": "B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.01920706592742695,
    "jaccard_score": 0.009900990099009901,
    "bleu_score": 0.0001802306132198423,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.9848569631576538,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\code_based\\test.py",
    "split_index": 1,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwi",
    "predicted_middle": "get_date(\"4-01-2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"4-01-2024\"))",
    "ground_truth_middle": "ec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_",
    "suffix": "formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.0831143072297192,
    "jaccard_score": 0.017241379310344827,
    "bleu_score": 0.018080543434590302,
    "rouge1": 0.11864406779661017,
    "rouge2": 0.017241379310344827,
    "rougeL": 0.11864406779661017,
    "confidence": 0.9993891716003418,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\code_based\\test.py",
    "split_index": 3,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#       ",
    "predicted_middle": "\"%d %m %Y\", \"%d %m %Y\", \"%d %m %Y\",\n#         \"%d %m %Y\", \"%d %m %Y\", \"%d %m %Y\", \"%d %m %Y\",\n#         \"%d %m %Y\", \"%d %m %Y\", \"%d %m %Y\", \"%d %m %Y\",\n#         \"%d %m %Y\", \"%d %m %Y\", \"%d %m %Y\", \"%d %m %Y\",\n#         \"%d %m %Y\", \"%d %m",
    "ground_truth_middle": "  \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data",
    "suffix": "}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.050995991289984346,
    "jaccard_score": 0.02830188679245283,
    "bleu_score": 0.010904462329480563,
    "rouge1": 0.18125,
    "rouge2": 0.031446540880503145,
    "rougeL": 0.18125,
    "confidence": 0.9927325248718262,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\code_based\\test.py",
    "split_index": 4,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#      ",
    "predicted_middle": "#     print(test_data)\n\n# print(get_date(\"10 05 24\"))\n# print(get_date(\"15 2024\"))\n# print(get_date(\"15 2024\"))\n# print(get_date(\"15 2024\"))\n# print(get_date(\"15 2024\"))\n# print(get_date(\"15 2024\"))\n# print(get_date(\"15 2024\"))\n# print(get",
    "ground_truth_middle": "       if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip",
    "suffix": " 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.4819383795860712,
    "jaccard_score": 0.06896551724137931,
    "bleu_score": 0.42347053496156545,
    "rouge1": 0.5490196078431373,
    "rouge2": 0.4,
    "rougeL": 0.5294117647058824,
    "confidence": 0.9837762713432312,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\code_based\\test2.py",
    "split_index": 1,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if r",
    "predicted_middle": ", data['result']['first_name'], data['result']['last_name'], data['result']['username'], data['result']['id'], data['result']['language'], data['result']['description'], data['result']['location'], data['result']['location_type'], data['result']['location_lat'], data['result']['location_lng'], data['result']['location_accuracy'], data['result']['location_accuracy_type'], data['result']['location_accuracy_lat'], data['result']['location_accuracy_lng'], data['result']['location_accuracy_accuracy'], data['result']['location_accuracy_accuracy",
    "ground_truth_middle": "esponse.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny.",
    "suffix": " Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.09488056832540724,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.05063291139240506,
    "rouge2": 0.0,
    "rougeL": 0.05063291139240506,
    "confidence": 0.9825375080108643,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  },
  {
    "file_path": "assets\\code_based\\test2.py",
    "split_index": 2,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description']",
    "predicted_middle": "#     print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#     print(\"ID:\", data['result']['id'])\n#     print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#     print(\"Imi\u0119:\", data['result']['first_name'])\n#\n#     print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#     print(\"ID:\", data['result']['id'])\n#     print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#     print(\"Imi\u0119:\",",
    "ground_truth_middle": ")\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token",
    "suffix": "\"\n# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.17499226235784082,
    "jaccard_score": 0.02631578947368421,
    "bleu_score": 0.038445352616647874,
    "rouge1": 0.024691358024691357,
    "rouge2": 0.0,
    "rougeL": 0.024691358024691357,
    "confidence": 0.9947275519371033,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  },
  {
    "file_path": "assets\\code_based\\test2.py",
    "split_index": 3,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         ",
    "predicted_middle": "#     else:\n#         print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#\n#\n# def get_bot_info(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o",
    "ground_truth_middle": "print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n",
    "suffix": "# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.2209274691090752,
    "jaccard_score": 0.041666666666666664,
    "bleu_score": 0.0407422753935356,
    "rouge1": 0.12820512820512822,
    "rouge2": 0.0,
    "rougeL": 0.10256410256410255,
    "confidence": 0.9835195541381836,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  },
  {
    "file_path": "assets\\code_based\\test2.py",
    "split_index": 4,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['use",
    "predicted_middle": "#     # Wstaw wyswietlko u\u017cytkownika\n#     url = f\"https://api.telegram.org/bot{token}/getUpdates\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['use",
    "ground_truth_middle": "rname'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#        ",
    "suffix": " print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.352559232372614,
    "jaccard_score": 0.02631578947368421,
    "bleu_score": 0.18346789441558775,
    "rouge1": 0.14705882352941177,
    "rouge2": 0.030303030303030304,
    "rougeL": 0.14705882352941177,
    "confidence": 0.9828524589538574,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  }
]
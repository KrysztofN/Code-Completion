[
  {
    "file_path": "assets\\code_based\\actions.py",
    "split_index": 0,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events imp",
    "predicted_middle": "ort Restarted, FollowupAction\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.forms import FormAction, FormField\nfrom rasa_sdk.events import SlotSet, FollowupAction\nfrom rasa_sdk.forms import FormField, TextInput, TextOutput\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.forms import FormAction, FormField\nfrom rasa_sdk.forms import FormField, TextInput, TextOutput\nfrom rasa_sdk.events import SlotSet, FollowupAction\nfrom rasa_",
    "ground_truth_middle": "ort SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(te",
    "suffix": "xt=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.10559122533409519,
    "jaccard_score": 0.023391812865497075,
    "bleu_score": 0.0,
    "rouge1": 0.07262569832402235,
    "rouge2": 0.0056179775280898875,
    "rougeL": 0.06145251396648044,
    "confidence": 0.9565187096595764,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\code_based\\actions.py",
    "split_index": 1,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter",
    "predicted_middle": "zno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno\u015b\u0107 powietrzno\u015b\u0107, wilgotno",
    "ground_truth_middle": "_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openw",
    "suffix": "eathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.07462944618620214,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.9915159344673157,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\code_based\\actions.py",
    "split_index": 2,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity",
    "predicted_middle": "hour == 12 and date.minute == 0:\n                            desc = item['description']\n                            temp = item['temp']\n                            humidity = item['humidity']\n                            wind_speed = item['wind_speed']\n                            clouds = item['clouds']\n\n                    dispatcher.utter_message(text=f\"Ostatnie w {city} na {specific_date.strftime('%d.%m.%Y')}\")\n                    dispatcher.utter_message(text=f\"Ostatnie w {city} na {specific_date.strftime('%d.%m.%Y')}, {desc}\")\n                    dispatcher.utter_message",
    "ground_truth_middle": ", wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_messag",
    "suffix": "e(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.3542300804137781,
    "jaccard_score": 0.0,
    "bleu_score": 0.08680088889422909,
    "rouge1": 0.21951219512195122,
    "rouge2": 0.15,
    "rougeL": 0.21951219512195122,
    "confidence": 0.9624746441841125,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\code_based\\actions.py",
    "split_index": 4,
    "prefix": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction,",
    "predicted_middle": "Restarted\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.forms import FormAction\nfrom rasa_sdk.forms import FormField\nfrom rasa_sdk.forms import FormFieldWithButtons\nfrom rasa_sdk.forms import FormFieldWithText\nfrom rasa_sdk.forms import FormFieldWithSelect\nfrom rasa_sdk.forms import FormFieldWithSubmit\nfrom rasa_sdk.forms import FormFieldWithTime\nfrom rasa_sdk.forms import FormFieldWithSelectMultiple\nfrom rasa_sdk.forms import FormFieldWithTime",
    "ground_truth_middle": " Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                 ",
    "suffix": "   city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n",
    "exact_match": false,
    "chrf_score": 0.11526578138312006,
    "jaccard_score": 0.027522935779816515,
    "bleu_score": 0.0,
    "rouge1": 0.05737704918032787,
    "rouge2": 0.008264462809917356,
    "rougeL": 0.05737704918032787,
    "confidence": 0.9808158874511719,
    "original_text": "from typing import Any, Text, Dict, List\nfrom rasa_sdk import Action, Tracker\nfrom rasa_sdk.events import SlotSet, FollowupAction, Restarted\nfrom .date_check import get_date\nfrom .calc_diff import calc_dif\nimport datetime\nimport requests\n\n\nclass ActionWeatherNow(Action):\n\n    def name(self) -> Text:\n        return \"action_tell_weather\"\n\n    def run(self, dispatcher, tracker, domain):\n\n            loc = tracker.get_slot('GPE')\n            date = tracker.get_slot('Date')\n\n\n            date = get_date(date)\n            if date is None:\n                dispatcher.utter_message(text=\"To nie jest poprawny format daty.\")\n                return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n\n            degree_sign = u'\\N{DEGREE SIGN}'\n            api_key = 'api_key'\n            payload = {'q': loc, 'units': 'metric', 'appid': api_key, 'lang': 'pl'}\n            response = requests.get('http://api.openweathermap.org/data/2.5/forecast', params=payload)\n\n            try:\n                data = response.json()\n                cur_date = datetime.datetime.now()\n                cur_date_o = datetime.datetime(cur_date.year, cur_date.month, cur_date.day)\n                timestamp1 = cur_date_o.timestamp()\n                timestamp2 = date.timestamp()\n                num = calc_dif(timestamp1, timestamp2)\n\n                if num < 0 or num > 5:\n                    dispatcher.utter_message(text=\"Nie jestem w stanie poda\u0107 pogody na wskazan\u0105 dat\u0119. Przewiduj\u0119 pogod\u0119 jedynie na 6 dni od dzisiejszej daty!\")\n                    return [SlotSet(\"Date\", None), FollowupAction(\"utter_date\")]\n                else:\n                    specific_date = datetime.datetime.now() + datetime.timedelta(days=num)\n                    city = data['city']['name']\n                    desc = None\n                    temp = None\n                    humidity = None\n                    wind_speed = None\n                    clouds = None\n\n                    for item in data['list']:\n                        date = datetime.datetime.utcfromtimestamp(item['dt'])\n                        if date.date() == specific_date.date():\n                            temp = item['main']['temp']\n                            desc = item['weather'][0]['description']\n                            humidity = item['main']['humidity']\n                            wind_speed = item['wind']['speed']\n                            clouds = item['clouds']['all']\n                            break\n\n                    weather_data = \"\"\"\n                                        Pogoda na ({}) w {}: \\n {}{}C. {} , wilgotno\u015b\u0107 powietrza na poziomie {}%. Pr\u0119dko\u015b\u0107 wiatru {} m/s. Zachmurzenie {}%.\"\"\".format(\n                        specific_date.strftime(\"%d-%m-%Y\"), city, temp, degree_sign, desc, humidity, wind_speed, clouds)\n                    dispatcher.utter_message(weather_data)\n                    return [SlotSet(\"GPE\", None), SlotSet(\"Date\", None)]\n\n            except (Exception, requests.exceptions.HTTPError) as e:\n                dispatcher.utter_message(text=\"Nie uda\u0142o si\u0119 znale\u017a\u0107 miasta! Sprawd\u017a pisowni\u0119\")\n                return [SlotSet(\"GPE\", None), FollowupAction(\"utter_loc\")]\n\n\nclass ActionRestartConversation(Action):\n    def name(self) -> Text:\n        return \"action_restart\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [Restarted()]\n\nclass ActionSetExecutedTrue(Action):\n\n    def name(self) -> str:\n        return \"action_set_executed_true\"\n\n    def run(self, dispatcher, tracker, domain):\n        return [SlotSet(\"terms\", True)]\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 0,
    "prefix": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 p",
    "predicted_middle": "yka.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})",
    "ground_truth_middle": "rywatno\u015bci przed kontynuacj\u0105.",
    "suffix": "'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.03990310895605299,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.9925717115402222,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 1,
    "prefix": "from flask import Flask, render_template, jsonify, req",
    "predicted_middle": "uest\nfrom flask_cors import CORS\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_migrate import Migrate\nfrom flask_login import LoginManager\nfrom flask_mail import Mail\nfrom flask_migrate import MigrateCommand\nfrom flask_bootstrap import Bootstrap\nfrom flask_moment import Moment\nfrom flask_wtf.csrf import CSRFProtect\nfrom flask_wtf.csrf import CSRFProtect\nfrom flask_wtf.csrf import CSRFProtect\nfrom flask_wtf.csrf import CSRFProtect\nfrom flask_wtf.csrf import CSRFProtect\nfrom flask_wtf.csrf import CSRFProtect\nfrom",
    "ground_truth_middle": "uest\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ ==",
    "suffix": " \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.10141953830839387,
    "jaccard_score": 0.023255813953488372,
    "bleu_score": 0.0,
    "rouge1": 0.028169014084507043,
    "rouge2": 0.0,
    "rougeL": 0.028169014084507043,
    "confidence": 0.9832258224487305,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 2,
    "prefix": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_re",
    "predicted_middle": "sponses)\n\n    print(\"Bot Response: \", bot_response)\n\n    if bot_response == 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.':\n        policy_accepted = True\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105",
    "ground_truth_middle": "sponses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki",
    "suffix": " prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.4707654679252116,
    "jaccard_score": 0.18181818181818182,
    "bleu_score": 0.27586977150173164,
    "rouge1": 0.3283582089552239,
    "rouge2": 0.24615384615384614,
    "rougeL": 0.26865671641791045,
    "confidence": 0.9921467900276184,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 3,
    "prefix": "from flask im",
    "predicted_middle": "port Flask, jsonify, request\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app)\n\n# Rasa API URL\nRASA_API_URL = 'http://localhost:3000/rasa/v1'\n\n\n@app.route('/rasa', methods=['POST'])\ndef rasa():\n    user_message = request.json['message']",
    "ground_truth_middle": "port Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n   ",
    "suffix": " rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.3396957187055863,
    "jaccard_score": 0.26,
    "bleu_score": 0.2574524661980289,
    "rouge1": 0.4571428571428572,
    "rouge2": 0.2912621359223301,
    "rougeL": 0.38095238095238093,
    "confidence": 0.92826908826828,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\app.py",
    "split_index": 4,
    "prefix": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    glob",
    "predicted_middle": "g = request.get_json()\n    bot_response = requests.post(RASA_API_URL, json=globge)\n\n    return jsonify({'response': bot_response})\n\n@app.route('/webhook', methods=['GET'])\ndef webhook_get():\n    global policy_accepted\n    policy_accepted = False\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n@app.route('/webhook', methods=['POST'])\ndef webhook_post():\n    global policy_accepted\n    policy_accepted =",
    "ground_truth_middle": "al policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_response",
    "suffix": "s)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n",
    "exact_match": false,
    "chrf_score": 0.4150531046203996,
    "jaccard_score": 0.1016949152542373,
    "bleu_score": 0.25744630357736403,
    "rouge1": 0.37398373983739835,
    "rouge2": 0.23140495867768593,
    "rougeL": 0.21138211382113822,
    "confidence": 0.9911472201347351,
    "original_text": "from flask import Flask, render_template, jsonify, request\nimport requests\n\nRASA_API_URL = 'http://localhost:5005/webhooks/rest/webhook'\napp = Flask(__name__)\n\npolicy_accepted = False\n\n@app.route('/')\ndef index():\n    return render_template(\"weather_bot.html\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    global policy_accepted\n\n    if not policy_accepted:\n        return jsonify({'response': 'Prosz\u0119 zaakceptowa\u0107 nasz\u0105 polityk\u0119 prywatno\u015bci przed kontynuacj\u0105.'})\n\n    user_message = request.json['message']\n    print(\"User message:\", user_message)\n\n    rasa_response = requests.post(RASA_API_URL, json={'message': user_message})\n    rasa_response_json = rasa_response.json()\n\n    print(\"Rasa Response: \", rasa_response_json)\n\n    bot_responses = [response.get('text', '') for response in rasa_response_json]\n    bot_response = ' '.join(bot_responses)\n\n    return jsonify({'response': bot_response})\n\n\n@app.route('/accept_policy', methods=['POST'])\ndef accept_policy():\n    global policy_accepted\n    policy_accepted = True\n    return jsonify({'message': 'Dzi\u0119kujemy za zaakceptowanie naszej polityki prywatno\u015bci.'})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=3000)\n"
  },
  {
    "file_path": "assets\\code_based\\calc_diff.py",
    "split_index": 0,
    "prefix": "\n# function to calculate the difference",
    "predicted_middle": "to the current date",
    "ground_truth_middle": " between\n# date ",
    "suffix": "from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.20855925331870273,
    "jaccard_score": 0.16666666666666666,
    "bleu_score": 0.0,
    "rouge1": 0.3333333333333333,
    "rouge2": 0.0,
    "rougeL": 0.3333333333333333,
    "confidence": 0.9448528289794922,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\code_based\\calc_diff.py",
    "split_index": 2,
    "prefix": "\n# function to calculat",
    "predicted_middle": "e the difference between two dates\ndef calc_dif_date(date1, date2):\n    return (date2 - date1)/86400\n\n# function to calculate the difference between two dates\ndef calc_dif_date_date(date1, date2):\n    return (date2 - date1)/86400\n\n# function to calculate the difference between two dates\ndef calc_dif_date_date_date(date1, date2):\n    return (date2 - date1)/86400\n\n# function to calculate the difference between two",
    "ground_truth_middle": "e the difference between\n# date from the user and current date (UNIT TIMES",
    "suffix": "TAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.24165902299270864,
    "jaccard_score": 0.19230769230769232,
    "bleu_score": 0.030188043146318778,
    "rouge1": 0.18666666666666668,
    "rouge2": 0.0821917808219178,
    "rougeL": 0.18666666666666668,
    "confidence": 0.9876090884208679,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\code_based\\calc_diff.py",
    "split_index": 3,
    "prefix": "\n# function to calculate the difference between\n# date from the user and current date (U",
    "predicted_middle": "ser)\ndef calculate_difference(date1, date2):\n    result = date2 - date1\n    result = result.days\n    result = result.seconds\n    result = result.microseconds\n    result = result.days*86400\n    result = result.seconds*1000\n    result = result.microseconds*1000\n    result = result.days*86400\n    result = result.seconds*1000\n    result = result.microseconds*1000\n    result = result.days*86400\n    result = result.",
    "ground_truth_middle": "NIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - d",
    "suffix": "ate1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.28722835144030934,
    "jaccard_score": 0.23809523809523808,
    "bleu_score": 0.0921890288468912,
    "rouge1": 0.1724137931034483,
    "rouge2": 0.10714285714285714,
    "rougeL": 0.1724137931034483,
    "confidence": 0.9892662763595581,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\code_based\\calc_diff.py",
    "split_index": 4,
    "prefix": "\n# function",
    "predicted_middle": "s\ndef calculate_date(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n\n# functions\ndef calculate_date_2(d",
    "ground_truth_middle": " to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(d",
    "suffix": "ate1, date2):\n    result = (date2 - date1)/86400\n    return result\n",
    "exact_match": false,
    "chrf_score": 0.2551286910343699,
    "jaccard_score": 0.07692307692307693,
    "bleu_score": 0.0,
    "rouge1": 0.2777777777777778,
    "rouge2": 0.0,
    "rougeL": 0.2222222222222222,
    "confidence": 0.9408331513404846,
    "original_text": "\n# function to calculate the difference between\n# date from the user and current date (UNIT TIMESTAMP)\ndef calc_dif(date1, date2):\n    result = (date2 - date1)/86400\n    return result\n"
  },
  {
    "file_path": "assets\\code_based\\date_check.py",
    "split_index": 0,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"Ap",
    "predicted_middle": "y\",\n        \"d\u0142ugo\u015b\u0107\": \"April\", \"d\u0142ugo\u015b\u0107\": \"May\", \"d\u0142ugo\u015b\u0107\": \"June\",\n        \"d\u0142ugo\u015b\u0107\": \"July\", \"d\u0142ugo\u015b\u0107\": \"August\", \"d\u0142ugo\u015b\u0107\": \"September\",\n        \"d\u0142ugo\u015b\u0107\": \"October\", \"d\u0142ugo\u015b\u0107\": \"November\", \"d\u0142ugo\u015b\u0107\": \"December\",\n        \"d\u0142ugo\u015b\u0107\": \"December\", \"d\u0142ugo\u015b\u0107\": \"January\", \"d\u0142ugo\u015b\u0107\": \"February\",\n        \"d\u0142ugo\u015b\u0107\": \"March",
    "ground_truth_middle": "ril\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_format",
    "suffix": "s = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.2533258921795416,
    "jaccard_score": 0.12903225806451613,
    "bleu_score": 0.1505776393163152,
    "rouge1": 0.1322314049586777,
    "rouge2": 0.0,
    "rougeL": 0.1322314049586777,
    "confidence": 0.9867238998413086,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\code_based\\date_check.py",
    "split_index": 1,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y",
    "predicted_middle": "Y\", \"%B-%Y\", \"%B/%Y\", \"%B.%Y\", \"%B/%Y\",\n        \"%B %y\", \"%B-%y\", \"%B/%y\", \"%B.%Y\", \"%B/%Y\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\",",
    "ground_truth_middle": "\",\n        \"%B %d %y\"",
    "suffix": ", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.11688814751764026,
    "jaccard_score": 0.05,
    "bleu_score": 0.035344571863080376,
    "rouge1": 0.1090909090909091,
    "rouge2": 0.0,
    "rougeL": 0.1090909090909091,
    "confidence": 0.975385308265686,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\code_based\\date_check.py",
    "split_index": 3,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"M",
    "predicted_middle": "om\", \"juni\u0119\": \"Jun\", \"juni\u0119\": \"Jul\", \"juni\u0119\": \"Aug\", \"juni\u0119\": \"Sep\",\n        \"juni\u0119\": \"Oct\", \"juni\u0119\": \"Nov\", \"juni\u0119\": \"Dec\", \"juni\u0119\": \"Jan\", \"juni\u0119\": \"Feb\", \"juni\u0119\": \"Mar\",\n        \"juni\u0119\": \"Apr\", \"juni\u0119\": \"May\", \"juni\u0119\": \"Jun\", \"juni\u0119\": \"Jul\", \"juni\u0119\": \"Aug\", \"juni\u0119",
    "ground_truth_middle": "ar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data",
    "suffix": " = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.11321264219823074,
    "jaccard_score": 0.0851063829787234,
    "bleu_score": 0.013069367266802492,
    "rouge1": 0.08294930875576037,
    "rouge2": 0.0,
    "rougeL": 0.06451612903225806,
    "confidence": 0.9793470501899719,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\code_based\\date_check.py",
    "split_index": 4,
    "prefix": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie",
    "predicted_middle": "\", \"sie\": \"Oct\", \"sie\u0144\": \"Nov\", \"sie\u0144\": \"Dec\", \"sie\u0144\": \"Jan\",\n        \"sie\u0144\": \"Feb\", \"sie\u0144\": \"Mar\", \"sie\u0144\": \"Apr\", \"sie\u0144\": \"May\", \"sie\u0144\": \"Jun\", \"sie\u0144\": \"Jul\",\n        \"sie\u0144\": \"Aug\", \"sie\u0144\": \"Sep\", \"sie\u0144\": \"Oct\", \"sie\u0144\": \"Nov\", \"sie\u0144\": \"Dec\", \"sie\u0144\": \"",
    "ground_truth_middle": "\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d",
    "suffix": " %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n",
    "exact_match": false,
    "chrf_score": 0.09750373931551394,
    "jaccard_score": 0.04819277108433735,
    "bleu_score": 0.016017488725824407,
    "rouge1": 0.05128205128205128,
    "rouge2": 0.0,
    "rougeL": 0.05128205128205128,
    "confidence": 0.9947085976600647,
    "original_text": "from datetime import datetime\n\n\ndef convert_date(date_str):\n    month_pl = {\n        \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n        \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n        \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n        \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n    }\n\n    for pl_month, en_month in month_pl.items():\n        date_str = date_str.replace(pl_month, en_month)\n\n    return date_str\n\n\ndef get_date(data_str):\n    data_str = convert_date(data_str)\n    data_str = data_str.lower()\n\n    date_formats = [\n        \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n        \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n        \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n        \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n        \"%d-%B\", \"%d.%B\", \"%d/%B\",\n        \"%d-%b\", \"%d.%b\", \"%d/%b\",\n        \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n        \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n        \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n        \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n        \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n        \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n    ]\n\n    for date_format in date_formats:\n        try:\n            data = datetime.strptime(data_str, date_format)\n            if \"%Y\" not in date_format:\n                data = data.replace(year=datetime.now().year)\n            return data\n        except ValueError:\n            pass\n\n    return None\n"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 0,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, boa",
    "predicted_middle": "n, board_size, lenght):\n        \"\"\"\n        Initialize the player.\n        \"\"\"\n        self.board_size = board_size\n        self.lenght = lenght\n        self.boa = boa\n        self.score = 0\n        self.is_flexible = False\n        self.is_win = False\n\n    def __str__(self):\n        \"\"\"\n        Return a string representation of the player.\n        \"\"\"\n        return f\"Player {self.name} with {self.board_size}x{self.lenght} board\"\n\n    def __repr__(self):\n        \"\"\"\n        Return a string",
    "ground_truth_middle": "rd_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0",
    "suffix": "\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.17268174820484025,
    "jaccard_score": 0.0851063829787234,
    "bleu_score": 0.04086785609915989,
    "rouge1": 0.2517482517482518,
    "rouge2": 0.05633802816901409,
    "rougeL": 0.18181818181818182,
    "confidence": 0.944936215877533,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 1,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_ne",
    "predicted_middle": "w: int,",
    "ground_truth_middle": "eded: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self,",
    "suffix": " player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.00821377435833621,
    "jaccard_score": 0.017241379310344827,
    "bleu_score": 0.0,
    "rouge1": 0.025,
    "rouge2": 0.0,
    "rougeL": 0.025,
    "confidence": 0.9103198051452637,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 2,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for e",
    "predicted_middle": "xisting.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_score(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the score of the player.\n        The board is represented as a numpy array of size (board_height, board_width) with 0 for existing.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_score_win(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the score of the player who wins.\n        The board is represented as a numpy array of size (board_height, board_width) with 0 for e",
    "ground_truth_middle": "mpty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player",
    "suffix": " 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.3157738050784231,
    "jaccard_score": 0.1774193548387097,
    "bleu_score": 0.16282425347037754,
    "rouge1": 0.34108527131782945,
    "rouge2": 0.09448818897637794,
    "rougeL": 0.24806201550387597,
    "confidence": 0.9705324172973633,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 3,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n",
    "predicted_middle": "def get_player_id(self) -> int:\n        \"\"\"\n        Returns the player's id.\n        \"\"\"\n        return self.player_id\n    \n    def get_board_size(self) -> int:\n        \"\"\"\n        Returns the board size.\n        \"\"\"\n        return self.board_width * self.board_height\n    \n    def get_lenght_needed(self) -> int:\n        \"\"\"\n        Returns the lenght needed.\n        \"\"\"\n        return self.lenght_needed\n    \n    def get_train(self) -> bool:\n        \"\"\"\n        Returns the train parameter.\n        \"\"\"\n        return self.train\n    \n    def",
    "ground_truth_middle": "      \n    @abstractmethod\n    ",
    "suffix": "def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.04516244231479608,
    "jaccard_score": 0.0,
    "bleu_score": 0.0,
    "rouge1": 0.0,
    "rouge2": 0.0,
    "rougeL": 0.0,
    "confidence": 0.9793614149093628,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\myplayer.py",
    "split_index": 4,
    "prefix": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.",
    "predicted_middle": ".\n        \"\"\"\n        self.board = np.zeros((self.board_width, self.board_height), dtype=int)\n        self.player_id = None\n        self.move_count = 0\n        self.win_count = 0\n        self.move_count_max = 0\n        self.win_count_max = 0\n        self.move_count_min = 0\n        self.win_count_min = 0\n        self.move_count_avg = 0\n        self.win_count_avg = 0\n        self.move_count_std",
    "ground_truth_middle": "\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n     ",
    "suffix": "   \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False",
    "exact_match": false,
    "chrf_score": 0.13838674987546803,
    "jaccard_score": 0.021505376344086023,
    "bleu_score": 0.03185900187257254,
    "rouge1": 0.1904761904761905,
    "rouge2": 0.06417112299465241,
    "rougeL": 0.11640211640211642,
    "confidence": 0.9659402966499329,
    "original_text": "import numpy as np\nfrom abc import ABC, abstractmethod\n\nclass Player(ABC):\n    \"\"\"\n    An abstract class to represent a player. \n    \"\"\"\n    def __init__(self, board_width: int, board_height: int, lenght_needed: int, train: bool) -> None:\n        self.board_width = board_width\n        self.board_height = board_height\n        self.lenght_needed = lenght_needed\n        self.train = train\n        self.player_id = None\n        \"\"\"\n        Initialize the player. The board width and height are given, as well as the number of pieces needed to win.\n        The train parameter can be ignored when writing algorithms. When train is False and the player is trainable the class should load the model state.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def start_game(self, player_id: int) -> None:\n        \"\"\"\n        Called when a new game starts.\n        The player_id is 1 if the player is player 1 and 2 if the player is player 2.\n        It is imortant reading the board.\n        \"\"\"\n        pass\n      \n    @abstractmethod\n    def get_move(self, board: np.ndarray) -> int:\n        \"\"\"\n        Returns the column the player wants to play in (0 based indexing). The move must be a valid move.\n        the board is represented as a numpy array of size (board_height, board_width) with 0 for empty, 1 for player 1 and 2 for player 2.\n        \"\"\"\n        pass\n      \n    def end_game(self, result: int) -> None:\n        pass\n        \n    def evaluate_position(self, board: np.ndarray, player_moving_id: int) -> float:\n        \"\"\"\n        Evaluate the position of the board. The result should be between -1 and 1. \n        Negative values meaning the player 1 is winning, positive values meaning player 2 is winning.\n        \"\"\"\n        return 0\n      \n    @property\n    def flexible(self):\n        \"\"\"\n        Return True if the player is flexible (can use any board size and lenght needed to win), False otherwise.\n        \"\"\"\n        return False"
  },
  {
    "file_path": "assets\\code_based\\player.py",
    "split_index": 1,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        bes",
    "predicted_middle": "board = np.copy(board_copy)\n                    new_board[col, :] = 0\n                    new_board[col, 0] = 0\n                    new_board[col, self.board_height - 1] = 0\n                    new_board[col, self.board_height] = 0\n                    new_board[col, self.board_width - 1] = 0\n                    new_board[col, self.board_width] = 0\n                    new_board[col, self.board_height - 1] = 0\n                    new_board[",
    "ground_truth_middle": "t_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = ",
    "suffix": "AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.0411450375074653,
    "jaccard_score": 0.02608695652173913,
    "bleu_score": 1.1114157389910544e-07,
    "rouge1": 0.09233997901364113,
    "rouge2": 0.033648790746582544,
    "rougeL": 0.08814270724029381,
    "confidence": 0.9731730818748474,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\code_based\\player.py",
    "split_index": 2,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta,",
    "predicted_middle": "board = np.copy(board_copy)\n                    new_board[col, :] = 0\n                    new_board[col, self.board_height-1] = 0\n                    new_board[col, self.board_height] = 0\n                    new_board[col, self.board_width-1] = 0\n                    new_board[col, self.board_width] = 0\n                    new_board[col, self.board_height-1] = 0\n                    new_board[col, self.board_height] = 0\n                    new_board[",
    "ground_truth_middle": " True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in rang",
    "suffix": "e(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.186061383259713,
    "jaccard_score": 0.02666666666666667,
    "bleu_score": 0.03286949233153524,
    "rouge1": 0.3245614035087719,
    "rouge2": 0.09734513274336283,
    "rougeL": 0.2543859649122807,
    "confidence": 0.9796916842460632,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\code_based\\player.py",
    "split_index": 3,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window ==",
    "predicted_middle": "board = np.copy(board_copy)\n                    new_board[col, :] = 0\n                    new_board[0, col] = 0\n                    new_board[self.board_width-1, col] = 0\n                    new_board[0, 0] = 0\n                    new_board[self.board_width-1, self.board_height-1] = 0\n                    new_board[0, self.board_height-1] = 0\n                    new_board[0, 0] = 0\n                    new_board[0, self.",
    "ground_truth_middle": " opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >",
    "suffix": "= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.06060948221473327,
    "jaccard_score": 0.025,
    "bleu_score": 1.7716491702543476e-05,
    "rouge1": 0.14173228346456695,
    "rouge2": 0.06635071090047392,
    "rougeL": 0.12598425196850394,
    "confidence": 0.975337028503418,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\code_based\\player.py",
    "split_index": 4,
    "prefix": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n      ",
    "predicted_middle": "== board[row + 3, col + 3]\n                    and board[row, col]!= 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board",
    "ground_truth_middle": "  return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_",
    "suffix": "width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()",
    "exact_match": false,
    "chrf_score": 0.075795446976944,
    "jaccard_score": 0.10982658959537572,
    "bleu_score": 5.928918858786909e-05,
    "rouge1": 0.16,
    "rouge2": 0.09698996655518395,
    "rougeL": 0.13,
    "confidence": 0.9993942975997925,
    "original_text": "import numpy as np\nfrom Player import *\nimport random\n\nclass MyPlayer(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n        while True:\n            try:\n                column = int(input(f\"Gracz {self.player_id}, wybierz kolumn\u0119 (1-{self.board_width}): \"))\n                if 1 <= column < self.board_width +1 and board[0, column-1] == 0:\n                    return column - 1\n                else:\n                    print(\"Ta kolumna jest ju\u017c pe\u0142na lub wpisa\u0142e\u015b niepoprawn\u0105 liczb\u0119!\")\n            except ValueError:\n                print(\"To musi by\u0107 LICZBA z przedzia\u0142u 1-7 \")\n\n    def end_game(self, result):\n        pass\n        \n\n    def evaluate_position(self, board, player_moving_id):\n        return 0\n\n    @property\n    def flexible(self):\n        return False\n    \nclass AI_Player(Player):\n    def __init__(self, board_width, board_height, length_needed, train):\n        super().__init__(board_width, board_height, length_needed, train)\n        self.max_depth = 3\n\n    def start_game(self, player_id):\n        self.player_id = player_id\n\n    def get_move(self, board):\n    \n        best_move, _ = self.minimax(board, self.max_depth, -float('inf'), float('inf'), False)\n        return best_move\n\n    def minimax(self, board, depth, alpha, beta, maximizing_player):\n        if depth == 0 or self.is_terminal(board):\n            return None, self.evaluate_position(board, self.player_id)\n\n        best_move = None\n        if maximizing_player:\n            max_eval = -float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, False)\n                    if eval_score > max_eval:\n                        max_eval = eval_score\n                        best_move = col\n                    alpha = max(alpha, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, max_eval\n        else:\n            min_eval = float('inf')\n            for col in range(self.board_width):\n                if self.is_valid_move(col, board):\n                    board_copy = np.copy(board)\n                    new_board = self.make_move(col, 3 - self.player_id, board_copy)\n                    _, eval_score = self.minimax(new_board, depth - 1, alpha, beta, True)\n                    if eval_score < min_eval:\n                        min_eval = eval_score\n                        best_move = col\n                    beta = min(beta, eval_score)\n                    if beta <= alpha:\n                        break\n            return best_move, min_eval\n\n    def is_terminal(self, board):\n        winner = self.check_winner(board)\n        if winner != -1:\n            return True\n        return np.count_nonzero(board) == board.size\n\n    def evaluate_position(self, board, player_moving_id):\n\n        heur = 0\n        score = 0\n        # ocena pozioma\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                score += self.evaluate_window(board[row, col:col+4], player_moving_id)\n\n        # ocena pionowa\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                score += self.evaluate_window(board[row:row+4, col], player_moving_id)\n\n        # ocena po przek\u0105tnej (w dwie strony)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                window = [board[row+i, col+i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n\n                window = [board[row+i, col+3-i] for i in range(4)]\n                score += self.evaluate_window(window, player_moving_id)\n                heur += score\n        return heur\n    \n    def evaluate_window(self, window, player_moving_id):\n       \n        opponent_id = 3 - player_moving_id\n        player_count = np.count_nonzero(window == player_moving_id)\n        empty_count = np.count_nonzero(window == 0)\n        opponent_count = np.count_nonzero(window == opponent_id)\n\n        if player_count == 4:\n            return 100000\n        elif player_count == 3 and empty_count == 1:\n            return 100\n        elif player_count == 2 and empty_count == 2:\n            return 1\n        elif opponent_count == 3 and empty_count == 1:\n            return -100000\n        else:\n            return 0\n    \n    #------------------------------------------------\n\n    def is_valid_move(self, column, board):\n        return 0 <= column < self.board_width and board[0, column] == 0\n\n    def make_move(self, column, player_id, board):\n        for row in range(self.board_height - 1, -1, -1):\n            if board[row, column] == 0:\n                board[row, column] = player_id\n                return board\n\n\n    def check_winner(self, board):\n        # sprawdzanie poziomo\n        for row in range(self.board_height):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row, col + 1] == board[row, col + 2] == board[row, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie pionowo\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col] == board[row + 2, col] == board[row + 3, col]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (g\u00f3ra-lewa do d\u00f3\u0142-prawa)\n        for row in range(self.board_height - 3):\n            for col in range(self.board_width - 3):\n                if (\n                    board[row, col] == board[row + 1, col + 1] == board[row + 2, col + 2] == board[row + 3, col + 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        # sprawdzanie przek\u0105tnej (prawo-g\u00f3ra do d\u00f3\u0142-lewa)\n        for row in range(self.board_height - 3):\n            for col in range(3, self.board_width):\n                if (\n                    board[row, col] == board[row + 1, col - 1] == board[row + 2, col - 2] == board[row + 3, col - 3]\n                    and board[row, col] != 0\n                ):\n                    return board[row, col]\n\n        return -1  \n\n    \nclass MyGame:\n    def __init__(self, player1, player2, board_width, board_height):\n        self.board = np.zeros((board_height, board_width), dtype=np.uint64)  \n        self.players = [player1, player2]\n\n    def start(self):\n        print(\"Witaj w grze Connect4!\")\n\n    def play_game(self):\n        current_player = random.randint(1, 2) #wybieramy losowo gracza\n        self.start()\n        while True:\n            #self.display_board()\n            player = self.players[current_player - 1]  \n            player.start_game(current_player)\n            column = player.get_move(self.board)\n            if self.is_valid_move(column):\n                self.make_move(column, current_player)\n                self.display_board()\n                result = self.check_winner()\n                if result != -1:\n                    self.display_board()\n                    self.end_game(result, current_player)\n                    break\n            current_player = 3 - current_player\n\n    def is_valid_move(self, column):\n        return 0 <= column < self.board.shape[1] and self.board[0, column] == 0\n\n    def make_move(self, column, player_id):\n        for row in range(self.board.shape[0] - 1, -1, -1):\n            if self.board[row, column] == 0:\n                self.board[row, column] = player_id\n                break\n\n    def check_winner(self):\n        for player_id in [1, 2]:\n            for row in range(self.board.shape[0]):\n                for col in range(self.board.shape[1]):\n                    if self.board[row, col] == player_id:\n                        if self.check_direction(row, col, player_id, 1, 0):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 0, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, 1):\n                            return player_id\n                        if self.check_direction(row, col, player_id, 1, -1):\n                            return player_id\n        if np.count_nonzero(self.board) == self.board.size:\n            return 0  # Remis\n        return -1\n\n    def check_direction(self, row, col, player_id, dr, dc):\n        for _ in range(self.players[0].lenght_needed - 1):\n            row += dr\n            col += dc\n            if row < 0 or row >= self.board.shape[0] or col < 0 or col >= self.board.shape[1] or self.board[row, col] != player_id:\n                return False\n        return True\n\n    def display_board(self):\n        for row in range(self.board.shape[0]):\n            row_str = \"|\"\n            for col in range(self.board.shape[1]):\n                cell_value = self.board[row, col]\n                if cell_value == 0:\n                    row_str += \" 0 |\"\n                else:\n                    row_str += f\" {int(cell_value)} |\"\n            print(row_str)\n        print(\" -\" * (2 * self.board.shape[1]))\n        print(\"  \" + \"   \".join(str(i) for i in range(1,self.board.shape[1]+1)))\n\n\n    def end_game(self, result, player_id):\n        if result == player_id:\n            print(f\"Gracz {player_id} wygrywa!\")\n        elif result == 0:\n            print(\"No kurczaki, REMIS!\")\n\nif __name__ == \"__main__\":\n    player1 = AI_Player(7, 6, 4, False)\n    player2 = MyPlayer(7, 6, 4, False)\n    game = MyGame(player1, player2, 7, 6)\n    game.play_game()"
  },
  {
    "file_path": "assets\\code_based\\test.py",
    "split_index": 0,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n# ",
    "predicted_middle": "2024\"))\n# # print(get_date(\"10 05 24 2024\"))\n# # print(get_date(\"10 05 24 2024 2024\"))\n# # print(get_date(\"10 05 24 2024 2024\"))\n# # print(get_date(\"10 05 24 2024 2024 2024\"))\n# # print(get_date(\"1",
    "ground_truth_middle": "    month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%",
    "suffix": "B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.04038439300776419,
    "jaccard_score": 0.009708737864077669,
    "bleu_score": 0.00019015077033599035,
    "rouge1": 0.058252427184466014,
    "rouge2": 0.00980392156862745,
    "rougeL": 0.058252427184466014,
    "confidence": 0.9875317811965942,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\code_based\\test.py",
    "split_index": 1,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwi",
    "predicted_middle": "convert_date(\"2019-01-01\"))\n# # print(convert_date(\"2019-01-02\"))\n# # print(convert_date(\"2019-01-03\"))\n# # print(convert_date(\"2019-01-04\"))\n# # print(convert_date(\"2019-01-05\"))\n# # print(convert_date(\"2019-01-06\"))\n# # print(convert_date(\"2019",
    "ground_truth_middle": "ec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_",
    "suffix": "formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.1042116336258636,
    "jaccard_score": 0.015873015873015872,
    "bleu_score": 0.01679010684379598,
    "rouge1": 0.12068965517241378,
    "rouge2": 0.017543859649122806,
    "rougeL": 0.12068965517241378,
    "confidence": 0.99305260181427,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\code_based\\test.py",
    "split_index": 3,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#       ",
    "predicted_middle": "\",\n#         \"%d-%m\", \"%d.%m\", \"%d/%m\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m\", \"%d.%m\", \"%d/%m\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m\", \"%d.%m\", \"%d/%m\",",
    "ground_truth_middle": "  \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data",
    "suffix": "}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.0774699839640053,
    "jaccard_score": 0.03669724770642202,
    "bleu_score": 0.022975963031386496,
    "rouge1": 0.18412698412698414,
    "rouge2": 0.051118210862619806,
    "rougeL": 0.17142857142857143,
    "confidence": 0.9933476448059082,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\code_based\\test.py",
    "split_index": 4,
    "prefix": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#      ",
    "predicted_middle": "\",\n#         \"%d-%m\", \"%d.%m\", \"%d/%m\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d.%m.%Y\", \"%d/%m/%Y\",\n#         \"%d-%m-%Y\", \"%d.%",
    "ground_truth_middle": "       if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip",
    "suffix": " 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n",
    "exact_match": false,
    "chrf_score": 0.0299363221006875,
    "jaccard_score": 0.03225806451612903,
    "bleu_score": 0.0,
    "rouge1": 0.018691588785046728,
    "rouge2": 0.0,
    "rougeL": 0.018691588785046728,
    "confidence": 0.9933476448059082,
    "original_text": "# from datetime import datetime\n\n# # used for \"month:day\" format\n# from datetime import datetime\n\n\n# def convert_date(date_str):\n#     month_pl = {\n#         \"stycze\u0144\": \"January\", \"luty\": \"February\", \"marzec\": \"March\", \"kwiecie\u0144\": \"April\", \"maj\": \"May\",\n#         \"czerwiec\": \"June\", \"lipiec\": \"July\", \"sierpie\u0144\": \"August\", \"wrzesie\u0144\": \"September\", \"pa\u017adziernik\": \"October\",\n#         \"listopad\": \"November\", \"grudzie\u0144\": \"December\", \"sty\": \"Jan\", \"lut\": \"Feb\", \"mar\": \"Mar\", \"kwi\": \"Apr\",\n#         \"maj\": \"May\", \"cze\": \"Jun\", \"lip\": \"Jul\", \"sie\": \"Aug\", \"wrz\": \"Sep\", \"pa\u017a\": \"Oct\", \"lis\": \"Nov\", \"gru\": \"Dec\"\n#     }\n\n#     for pl_month, en_month in month_pl.items():\n#         date_str = date_str.replace(pl_month, en_month)\n\n#     return date_str\n\n\n# def get_date(data_str):\n#     data_str = convert_date(data_str)\n#     data_str = data_str.lower()\n\n#     date_formats = [\n#         \"%d %b %Y\", \"%d %B %Y\", \"%d %b %y\", \"%d %B %y\",\n#         \"%d %B\", \"%d %b\", \"%d-%B-%y\", \"%d.%B.%y\", \"%d/%B/%y\",\n#         \"%d-%B-%Y\", \"%d.%B.%Y\", \"%d/%B/%Y\",\n#         \"%d-%b-%Y\", \"%d.%b.%Y\", \"%d/%b/%Y\",\n#         \"%d-%B\", \"%d.%B\", \"%d/%B\",\n#         \"%d-%b\", \"%d.%b\", \"%d/%b\",\n#         \"%d %m %Y\", \"%d-%m-%Y\", \"%d/%m/%Y\", \"%d.%m.%Y\",\n#         \"%d %m %y\", \"%d-%m-%y\", \"%d/%m/%y\", \"%d.%m.%y\",\n#         \"%B %d\", \"%B-%d\", \"%B/%d\", \"%B.%d\",\n#         \"%B %d %Y\", \"%B/%d/%Y\", \"%B-%d-%Y\", \"%B.%d.%Y\",\n#         \"%B %d %y\", \"%B-%d-%y\", \"%B/%d/%y\", \"%B.%d.%y\",\n#         \"%d/%m\", \"%d-%m\", \"%d %m\", \"%d.%m\",\n#     ]\n\n#     for date_format in date_formats:\n#         try:\n#             data = datetime.strptime(data_str, date_format)\n#             if \"%Y\" not in date_format:\n#                 data = data.replace(year=datetime.now().year)\n#             return data\n#         except ValueError:\n#             pass\n\n#     return None\n\n\n# # print(get_date(\"4 stycze\u0144 2024\"))\n# # print(get_date(\"4.01.2024\"))\n# # print(get_date(\"4 sty 2024\"))\n# # print(get_date(\"4/01/2024\"))\n# # print(get_date(\"4-01-2024\"))\n# # print(get_date(\"04/01/2024\"))\n# # print(get_date(\"4 lip 2024\"))\n# # print(get_date(\"5 wrzesie\u0144 2024\"))\n# # print(get_date(\"7 lip 2024\"))\n# # print(get_date(\"9 gru 2024\"))\n# # print(get_date(\"12 luty\"))\n# # print(get_date(\"4 SIERpie\u0144\"))\n# # print(get_date(\"15 MAJ\"))\n# # print(get_date(\"sie 20\"))\n# # print(get_date(\"10 05 24\"))\n# # print(get_date(\"4 wrzesie\u0144 24\"))\n# # print(get_date(\"4.wrzesie\u0144.24\"))\n\n\n# test_dates = [\n#     \"4 10 24\", \"4-10-24\", \"4/10/24\", \"4.10.24\",\n#     \"4 stycze\u0144 2024\", \"4-stycze\u0144-2024\", \"4/stycze\u0144/2024\", \"4.stycze\u0144.2024\",\n#     \"4.01.2024\", \"4/01/2024\", \"4 01 2024\", \"4-01-2024\",\n#     \"4 sty 2024\", \"4-sty-2024\", \"4.sty.2024\", \"4/sty/2024\",\n#     \"4 lipiec\", \"4/lipiec\", \"4.lipiec\", \"4-lipiec\",\n#     \"7 lip\", \"7-lip\", \"7/lip\", \"7.lip\",\n#     \"4 wrzesie\u0144 24\", \"4/wrzesie\u0144/24\", \"4-wrzesie\u0144-24\", \"4.luty.24\", \"maj 15\", \"maj 15 2024\",\n#     \"stycze\u0144 20 24\", \"15-05\"\n# ]\n\n# for test_data in test_dates:\n#     print(f\"{test_data}: {get_date(test_data)}\")\n"
  },
  {
    "file_path": "assets\\code_based\\test2.py",
    "split_index": 1,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if r",
    "predicted_middle": "eponse.status_code == 200:\n#         print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", response.json())\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n#\n# # Wstaw sw\u00f3j token bota",
    "ground_truth_middle": "esponse.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny.",
    "suffix": " Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.3943374823552028,
    "jaccard_score": 0.0975609756097561,
    "bleu_score": 0.18221620650374432,
    "rouge1": 0.2058823529411765,
    "rouge2": 0.09090909090909091,
    "rougeL": 0.2058823529411765,
    "confidence": 0.984597384929657,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  },
  {
    "file_path": "assets\\code_based\\test2.py",
    "split_index": 2,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description']",
    "predicted_middle": ")\n#\n# token = \"",
    "ground_truth_middle": ")\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token",
    "suffix": "\"\n# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.054551473933291,
    "jaccard_score": 0.16,
    "bleu_score": 0.001752742473001697,
    "rouge1": 0.0625,
    "rouge2": 0.0,
    "rougeL": 0.0625,
    "confidence": 0.9036077857017517,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  },
  {
    "file_path": "assets\\code_based\\test2.py",
    "split_index": 3,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         ",
    "predicted_middle": "print(\"Nie mo\u017cna wykorzysta\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107\u0107",
    "ground_truth_middle": "print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n",
    "suffix": "# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.11066976444028112,
    "jaccard_score": 0.08695652173913043,
    "bleu_score": 0.003668448693854512,
    "rouge1": 0.2285714285714286,
    "rouge2": 0.18181818181818182,
    "rougeL": 0.2285714285714286,
    "confidence": 0.9830596446990967,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  },
  {
    "file_path": "assets\\code_based\\test2.py",
    "split_index": 4,
    "prefix": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['use",
    "predicted_middle": "_name'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['first_name'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['last_name'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['email'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['profile_image_url'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['profile_image_url_https'])\n#             print(\"Nazwa u\u017cytkown",
    "ground_truth_middle": "rname'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#        ",
    "suffix": " print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n",
    "exact_match": false,
    "chrf_score": 0.38329019260180575,
    "jaccard_score": 0.1,
    "bleu_score": 0.19585019757153443,
    "rouge1": 0.19178082191780824,
    "rouge2": 0.08450704225352113,
    "rougeL": 0.19178082191780824,
    "confidence": 0.9909769892692566,
    "original_text": "# import requests\n#\n# def check_bot(token):\n#     url = f\"https://api.telegram.org/bot{token}/getMe\"\n#     response = requests.get(url)\n#     if response.status_code == 200:\n#         data = response.json()\n#         if data['ok']:\n#             print(\"Bot jest dost\u0119pny. Oto informacje o bocie:\")\n#             print(\"ID:\", data['result']['id'])\n#             print(\"Nazwa u\u017cytkownika:\", data['result']['username'])\n#             print(\"Imi\u0119:\", data['result']['first_name'])\n#         else:\n#             print(\"Wyst\u0105pi\u0142 b\u0142\u0105d podczas sprawdzania bota:\", data['description'])\n#     else:\n#         print(\"Nie mo\u017cna po\u0142\u0105czy\u0107 si\u0119 z API Telegrama. Sprawd\u017a sw\u00f3j token i upewnij si\u0119, \u017ce masz po\u0142\u0105czenie internetowe.\")\n#\n# # Wstaw sw\u00f3j token bota\n# token = \"your-token\"\n# check_bot(token)\n"
  }
]